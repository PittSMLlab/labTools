function out = computeHreflexParameters(strideEvents,HreflexData, ...
    EMGData,slowLeg)
%This function computes summary H-reflex parameters per stride
%   This function outputs a 'parameterSeries' object, which can be
% concatenated with other 'parameterSeries' objects, for example, with
% those from 'computeTemporalParameters'. While this function is used for
% H-reflex parameters exclusively, it should work for any 'labTS' object.
% This function computes summary parameters per stride across three
% different muscles: SOL, MG, and LG.
%
% See also computeSpatialParameters, computeTemporalParameters,
% computeForceParameters, parameterSeries

% TODO: accept GRF data as input argument (if necessary) to leave as NaN
% strides for which stim occurs during double rather than single stance
% TODO: store parameters as a structure if possible to convert to
% 'parameterSeries' object to help code readability (i.e., far fewer lines)

%% Gait Stride Event Times
timeSHS = strideEvents.tSHS;    % slow heel strike event times
timeFTO = strideEvents.tFTO;    % fast toe off event times
timeFHS = strideEvents.tFHS;    % fast heel strike event times
timeSTO = strideEvents.tSTO;    % slow toe off event times
timeSHS2 = strideEvents.tSHS2;  % 2nd slow heel strike event times
timeFHS2 = strideEvents.tFHS2;  % 2nd fast heel strike event times

%% Labels & Descriptions
muscles = {'SOL','MG','LG'};
legs = {'Slow','Fast'};
% H-reflex stimulation timing and amplitude parameters
% TODO: add convenience parameter for percentage of stance phase
% TODO: consider implementing Wilson Amplitude, sample entropy, skewness,
%       kurtosis, or power spectrum deformation EMG parameters? Integrated
%       EMG or sample entropy can be used for onset detection (perhaps for
%       distinguishing H-reflex from background regions). Sample entropy is
%       especially robust to noise and can be used for EMG filtering.
%       Sample entropy can distinguish stroke (spastic) from healthy EMG.
% TODO: store timing of the H- and M-waves?
% "The H-reflex amplitude is simply the peak-to-peak measurement of reflex,
% and the BEMG is the average rectified EMG amplitude present in the muscle
% for some period before the stimulation. The window for BEMG measurement
% is typically between 50 and 100 milliseconds."
%   "The Hoffmann reflex: Methodologic considerations and applications for
%   use in sports medicine and athletic training research" Palmieri et al.
aux = { ...
    'stimTimeFromStanceSlow',       'time from SHS to slow leg stim (in s)'; ...
    'stimTimeFromStanceFast',       'time from FHS to fast leg stim (in s)'; ...
    'stimTimeFromSingleStanceSlow', 'time from FTO to slow leg stim (in s)'; ...
    'stimTimeFromSingleStanceFast', 'time from STO to fast leg stim (in s)'; ...
    'isSingleStanceSlow',           'is stim during slow leg single stance phase?'; ...
    'isSingleStanceFast',           'is stim during fast leg single stance phase?'; ...
    'HwaveAmpSlowSOL',              'peak-to-peak voltage of the slow leg SOL H-wave (in mV)'; ...
    'HwaveAmpFastSOL',              'peak-to-peak voltage of the fast leg SOL H-wave (in mV)'; ...
    'MwaveAmpSlowSOL',              'peak-to-peak voltage of the slow leg SOL M-wave (in mV)'; ...
    'MwaveAmpFastSOL',              'peak-to-peak voltage of the fast leg SOL M-wave (in mV)'; ...
    'HreflexNoiseAmpSlowSOL',       'peak-to-peak voltage of the slow leg SOL noise (in mV)'; ...
    'HreflexNoiseAmpFastSOL',       'peak-to-peak voltage of the fast leg SOL noise (in mV)'; ...
    'H2MAmpRatioSlowSOL',           'ratio of the slow leg SOL H-wave to M-wave amplitudes'; ...
    'H2MAmpRatioFastSOL',           'ratio of the fast leg SOL H-wave to M-wave amplitudes'; ...
    'HwaveRMSSlowSOL',              'root mean square over the slow leg SOL H-wave window (in mV)'; ...
    'HwaveRMSFastSOL',              'root mean square over the fast leg SOL H-wave window (in mV)'; ...
    'MwaveRMSSlowSOL',              'root mean square over the slow leg SOL M-wave window (in mV)'; ...
    'MwaveRMSFastSOL',              'root mean square over the fast leg SOL M-wave window (in mV)'; ...
    'HreflexNoiseRMSSlowSOL',       'root mean square over the slow leg SOL noise window (in mV)'; ...
    'HreflexNoiseRMSFastSOL',       'root mean square over the fast leg SOL noise window (in mV)'; ...
    'H2MRMSRatioSlowSOL',           'ratio of the slow leg SOL H-wave to M-wave RMS'; ...
    'H2MRMSRatioFastSOL',           'ratio of the fast leg SOL H-wave to M-wave RMS'; ...
    'HreflexBEMGRMSSlowSOL',        'root mean square of the slow leg SOL H-reflex background EMG (in mV)'; ...
    'HreflexBEMGRMSFastSOL',        'root mean square of the fast leg SOL H-reflex background EMG (in mV)'; ...
    'NoStimBEMGRMSSlowSOL',         'root mean square of the slow leg SOL EMG at mid-stance when no stimulation (in mV)'; ...
    'NoStimBEMGRMSFastSOL',         'root mean square of the fast leg SOL EMG at mid-stance when no stimulation (in mV)'; ...
    'HwaveAmpSlowMG',               'peak-to-peak voltage of the slow leg MG H-wave (in mV)'; ...
    'HwaveAmpFastMG',               'peak-to-peak voltage of the fast leg MG H-wave (in mV)'; ...
    'MwaveAmpSlowMG',               'peak-to-peak voltage of the slow leg MG M-wave (in mV)'; ...
    'MwaveAmpFastMG',               'peak-to-peak voltage of the fast leg MG M-wave (in mV)'; ...
    'HreflexNoiseAmpSlowMG',        'peak-to-peak voltage of the slow leg MG noise (in mV)'; ...
    'HreflexNoiseAmpFastMG',        'peak-to-peak voltage of the fast leg MG noise (in mV)'; ...
    'H2MAmpRatioSlowMG',            'ratio of the slow leg MG H-wave to M-wave amplitudes'; ...
    'H2MAmpRatioFastMG',            'ratio of the fast leg MG H-wave to M-wave amplitudes'; ...
    'HwaveRMSSlowMG',               'root mean square over the slow leg MG H-wave window (in mV)'; ...
    'HwaveRMSFastMG',               'root mean square over the fast leg MG H-wave window (in mV)'; ...
    'MwaveRMSSlowMG',               'root mean square over the slow leg MG M-wave window (in mV)'; ...
    'MwaveRMSFastMG',               'root mean square over the fast leg MG M-wave window (in mV)'; ...
    'HreflexNoiseRMSSlowMG',        'root mean square over the slow leg MG noise window (in mV)'; ...
    'HreflexNoiseRMSFastMG',        'root mean square over the fast leg MG noise window (in mV)'; ...
    'H2MRMSRatioSlowMG',            'ratio of the slow leg MG H-wave to M-wave RMS'; ...
    'H2MRMSRatioFastMG',            'ratio of the fast leg MG H-wave to M-wave RMS'; ...
    'HreflexBEMGRMSSlowMG',         'root mean square of the slow leg MG H-reflex background EMG (in mV)'; ...
    'HreflexBEMGRMSFastMG',         'root mean square of the fast leg MG H-reflex background EMG (in mV)'; ...
    'NoStimBEMGRMSSlowMG',          'root mean square of the slow leg MG EMG at mid-stance when no stimulation (in mV)'; ...
    'NoStimBEMGRMSFastMG',          'root mean square of the fast leg MG EMG at mid-stance when no stimulation (in mV)'; ...
    'HwaveAmpSlowLG',               'peak-to-peak voltage of the slow leg LG H-wave (in mV)'; ...
    'HwaveAmpFastLG',               'peak-to-peak voltage of the fast leg LG H-wave (in mV)'; ...
    'MwaveAmpSlowLG',               'peak-to-peak voltage of the slow leg LG M-wave (in mV)'; ...
    'MwaveAmpFastLG',               'peak-to-peak voltage of the fast leg LG M-wave (in mV)'; ...
    'HreflexNoiseAmpSlowLG',        'peak-to-peak voltage of the slow leg LG noise (in mV)'; ...
    'HreflexNoiseAmpFastLG',        'peak-to-peak voltage of the fast leg LG noise (in mV)'; ...
    'H2MAmpRatioSlowLG',            'ratio of the slow leg LG H-wave to M-wave amplitudes'; ...
    'H2MAmpRatioFastLG',            'ratio of the fast leg LG H-wave to M-wave amplitudes'; ...
    'HwaveRMSSlowLG',               'root mean square over the slow leg LG H-wave window (in mV)'; ...
    'HwaveRMSFastLG',               'root mean square over the fast leg LG H-wave window (in mV)'; ...
    'MwaveRMSSlowLG',               'root mean square over the slow leg LG M-wave window (in mV)'; ...
    'MwaveRMSFastLG',               'root mean square over the fast leg LG M-wave window (in mV)'; ...
    'HreflexNoiseRMSSlowLG',        'root mean square over the slow leg LG noise window (in mV)'; ...
    'HreflexNoiseRMSFastLG',        'root mean square over the fast leg LG noise window (in mV)'; ...
    'H2MRMSRatioSlowLG',            'ratio of the slow leg LG H-wave to M-wave RMS'; ...
    'H2MRMSRatioFastLG',            'ratio of the fast leg LG H-wave to M-wave RMS'; ...
    'HreflexBEMGRMSSlowLG',         'root mean square of the slow leg LG H-reflex background EMG (in mV)'; ...
    'HreflexBEMGRMSFastLG',         'root mean square of the fast leg LG H-reflex background EMG (in mV)'; ...
    'NoStimBEMGRMSSlowLG',          'root mean square of the slow leg LG EMG at mid-stance when no stimulation (in mV)'; ...
    'NoStimBEMGRMSFastLG',          'root mean square of the fast leg LG EMG at mid-stance when no stimulation (in mV)'};

% TODO: consider re-adding background EMG MAV parameters
% 'HreflexBEMGMAVSlowSOL',   'mean absolute value of the slow leg background EMG (in mV)'; ...
% 'HreflexBEMGMAVFastSOL',   'mean absolute value of the fast leg background EMG (in mV)'; ...
% 'HreflexBEMGMAVSlowMG',   'mean absolute value of the slow leg background EMG (in mV)'; ...
% 'HreflexBEMGMAVFastMG',   'mean absolute value of the fast leg background EMG (in mV)'; ...
% 'HreflexBEMGMAVSlowLG',   'mean absolute value of the slow leg background EMG (in mV)'; ...
% 'HreflexBEMGMAVFastLG',   'mean absolute value of the fast leg background EMG (in mV)'; ...

paramLabels = aux(:,1);
description = aux(:,2);

%% Initialize All Parameter Arrays
% initialize parameter arrays: stimulation timing and H-reflex amplitudes
% (i.e., peak-to-peak voltages and RMS)
stimTimeFromStanceSlow = nan(size(timeSHS));
stimTimeFromStanceFast = nan(size(timeFHS));
stimTimeFromSingleStanceSlow = nan(size(timeSHS));
stimTimeFromSingleStanceFast = nan(size(timeFHS));
isSingleStanceSlow = false(size(timeSHS));  % TODO: initialize true or NaN?
isSingleStanceFast = false(size(timeFHS));

for m = 1:length(muscles)               % for each muscle of interest, ...
    muscle = muscles{m};                % name of current muscle
    for l = 1:2                         % for slow (1) & fast (2) leg, ...
        leg = legs{l};                  % name of current leg
        % initialize parameter data arrays
        eval(['HwaveAmp' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['MwaveAmp' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['HreflexNoiseAmp' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['H2MAmpRatio' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['HwaveRMS' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['MwaveRMS' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['HreflexNoiseRMS' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['H2MRMSRatio' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['HreflexBEMGRMS' leg muscle ' = nan(size(time' leg(1) 'HS));']);
        eval(['NoStimBEMGRMS' leg muscle ' = nan(size(time' leg(1) 'HS));']);
    end
end

%% Identify Stimulus Artifact Indices
% extract time for the trial, and use proximal TA to localize stim artifact
[EMG_RTAP,times] = EMGData.getDataAsVector('RTAP');
EMG_LTAP = EMGData.getDataAsVector('LTAP');
stimTrigR = HreflexData.getDataAsVector( ...
    'Stimulator_Trigger_Sync_Right_Stimulator');
stimTrigL = HreflexData.getDataAsVector( ...
    'Stimulator_Trigger_Sync_Left__Stimulator');
indsStimArtifact = Hreflex.extractStimArtifactIndsFromTrigger( ...
    times,{EMG_RTAP,EMG_LTAP},{stimTrigR,stimTrigL});
if all(cellfun(@isempty,indsStimArtifact))          % if no stim, ...
    data = nan(length(timeSHS),length(paramLabels));
    for ii = 1:length(paramLabels)
        eval(['data(:,ii) = ' paramLabels{ii} ';']);
    end
    out = parameterSeries(data,paramLabels,[],description);
    return;                                         % return from function
end

%% Determine Which Leg is Slow and Which Leg is Fast
switch lower(slowLeg)   % which leg is slow, R or L
    case 'r'            % if right leg is slow, ...
        indSlow = 1;
        indFast = 2;
    case 'l'            % if left leg is slow, ...
        indSlow = 2;
        indFast = 1;
    otherwise           % otherwise, throw an error
        error('Invalid slow leg input argument, must be ''R'' or ''L''');
end

%% Compute H-Reflex Stimulation Timing Parameters
% NaN values give false in logical comparison
indsComp = all(~isnan([timeSHS timeFHS]),2);    % comparison inds (no NaNs)
% TODO: could also check the SHS2 and FHS2 times to be ultra safe
isSlowFirst = all(timeSHS(indsComp) < timeFHS(indsComp));

% find indices of nearest stride heel strike to the time of stim
% NOTE: this **should** be identical but may not be due to missed
% stimulation pulses, especially at start or end of trial (however,
% there should not be substantial differences in stride indices)
% TODO: add data check to warn if stride indices are considerably
% different across legs (i.e., not including strides where stim was missed)
timeStimSlow = times(indsStimArtifact{indSlow});
timeStimFast = times(indsStimArtifact{indFast});

% discard stimuli that occur too early (e.g., when H-reflex stim happens
% during a transition into a new condition or before a first valid HS is
% detected) or too late (e.g., more than 1 second after final HS)
% TODO: 1 second may not be the correct threshold here
timeSHSNoNaNs = timeSHS(~isnan(timeSHS));
timeFHSNoNaNs = timeFHS(~isnan(timeFHS));
shouldDiscardStimSlow = (timeStimSlow <= timeSHSNoNaNs(1)) | ...
    (timeStimSlow >= (timeSHSNoNaNs(end)+1));
shouldDiscardStimFast = (timeStimFast <= timeFHSNoNaNs(1)) | ...
    (timeStimFast >= (timeFHSNoNaNs(end)+1));
timeStimSlow = timeStimSlow(~shouldDiscardStimSlow);
timeStimFast = timeStimFast(~shouldDiscardStimFast);
if indSlow == 1     % if right leg is slow, ...
    indsStimArtValid = {indsStimArtifact{1}(~shouldDiscardStimSlow); ...
        indsStimArtifact{2}(~shouldDiscardStimFast)};
else                % otherwise, right leg is fast, ...
    indsStimArtValid = {indsStimArtifact{1}(~shouldDiscardStimFast); ...
        indsStimArtifact{2}(~shouldDiscardStimSlow)};
end
if any(shouldDiscardStimSlow)               % if discarding any stim, ...
    warning('Dropping %d stimuli for the slow leg', ...
        sum(shouldDiscardStimSlow));
end
if any(shouldDiscardStimFast)
    warning('Dropping %d stimuli for the fast leg', ...
        sum(shouldDiscardStimFast));
end

% compute valid stride indices corresponding from the filtered stim times
indsStimStrideSlow = arrayfun(@(x) ...
    find((x - timeSHS) > 0,1,'last'),timeStimSlow);
indsStimStrideFast = arrayfun(@(x) ...
    find((x - timeFHS) > 0,1,'last'),timeStimFast);

% create logical arrays for indexing for (valid) strides with stimulation
isStimStrideSlow = false(size(timeSHS));
isStimStrideFast = false(size(timeFHS));
isStimStrideSlow(indsStimStrideSlow) = true;
isStimStrideFast(indsStimStrideFast) = true;

% populate the times for the strides that have stimulation
stimTimeFromStanceSlow(isStimStrideSlow) = timeStimSlow - ...
    timeSHS(isStimStrideSlow);
stimTimeFromStanceFast(isStimStrideFast) = timeStimFast - ...
    timeFHS(isStimStrideFast);
stimTimeFromSingleStanceSlow(isStimStrideSlow) = timeStimSlow - ...
    timeFTO(isStimStrideSlow);
stimTimeFromSingleStanceFast(isStimStrideFast) = timeStimFast - ...
    timeSTO(isStimStrideFast);

if isSlowFirst  % if slow leg heel strikes first, ...
    % TODO: conditions return false if time is NaN - implement handling
    isSingleStanceSlow(isStimStrideSlow) = ...
        (timeStimSlow > timeSHS(isStimStrideSlow)) & ...
        (timeStimSlow < timeFHS(isStimStrideSlow));
    isSingleStanceFast(isStimStrideFast) = ...
        (timeStimFast > timeFHS(isStimStrideFast)) & ...
        (timeStimFast < timeSHS2(isStimStrideFast));
else            % otherwise, fast leg heel strikes first, ...
    isSingleStanceFast(isStimStrideFast) = ...
        (timeStimFast > timeFHS(isStimStrideFast)) & ...
        (timeStimFast < timeSHS(isStimStrideFast));
    isSingleStanceSlow(isStimStrideSlow) = ...
        (timeStimSlow > timeSHS(isStimStrideSlow)) & ...
        (timeStimSlow < timeFHS2(isStimStrideSlow));
end

%% Extract EMG Signal for Each H-Reflex Muscle of Interest
EMG_RSOL = EMGData.getDataAsVector('RSOL');
EMG_LSOL = EMGData.getDataAsVector('LSOL');
EMG_RMG = EMGData.getDataAsVector('RMG');
EMG_LMG = EMGData.getDataAsVector('LMG');
EMG_RLG = EMGData.getDataAsVector('RLG');
EMG_LLG = EMGData.getDataAsVector('LLG');
% organize EMG Data for Each Muscle
EMGDataByMuscle = {EMG_RSOL,EMG_LSOL; EMG_RMG,EMG_LMG; EMG_RLG,EMG_LLG};

%% Identify Indices of Mid-Single Stance (No Stim) using Valid Stim Strides
timesMidSingleStanceSlow = timeFTO + ((timeFHS - timeFTO) / 2);
timesMidSingleStanceFast = timeSTO + ((timeSHS2 - timeSTO) / 2);
indsMidSingleStanceSlow = nan(size(timesMidSingleStanceSlow));
indsMidSingleStanceFast = nan(size(timesMidSingleStanceFast));
isValidSlow = ~isnan(timesMidSingleStanceSlow);
isValidFast = ~isnan(timesMidSingleStanceFast);
indsMidSingleStanceSlow(isValidSlow) = arrayfun(@(x) ...
    find((x - times) > 0,1,'last'),timesMidSingleStanceSlow(isValidSlow));
indsMidSingleStanceFast(isValidFast) = arrayfun(@(x) ...
    find((x - times) > 0,1,'last'),timesMidSingleStanceFast(isValidFast));

%% Compute Backgound EMG Parameters
f = EMGData.sampFreq;                       % sampling frequency (2 kHz)
% percent of single stance phase before stimulation artifact background EMG
percentBefore = 0.05;
% number of samples in single stance phase for each stride
numSampsSingleStanceSlow = f * (timeFHS - timeFTO);
numSampsSingleStanceFast = f * (timeSHS2 - timeSTO);
% number of samples before artifact to extract background EMG window, which
% works out to be ~21 ms if single stance is ~422 ms.
numSampsBeforeSlow = round(numSampsSingleStanceSlow * percentBefore);
numSampsBeforeFast = round(numSampsSingleStanceFast * percentBefore);
opts.dur = 0.050;                           % 50 ms background EMG window
% use valid stimulation strides only when setting opts.numSampsBefore
if indSlow == 1                             % if right leg is slow, ...
    opts.numSampsBefore = {numSampsBeforeSlow(isStimStrideSlow); ...
        numSampsBeforeFast(isStimStrideFast)};
    indsNoStimBEMG = {indsMidSingleStanceSlow(~isStimStrideSlow) + 50; ...
        indsMidSingleStanceFast(~isStimStrideFast) + 50};
else                                        % otherwise, left is slow, ...
    opts.numSampsBefore = {numSampsBeforeFast(isStimStrideFast); ...
        numSampsBeforeSlow(isStimStrideSlow)};
    indsNoStimBEMG = {indsMidSingleStanceFast(~isStimStrideFast) + 50; ...
        indsMidSingleStanceSlow(~isStimStrideSlow) + 50};
end

%% Compute H-Reflex Parameters for Each Muscle of Interest
% TODO: further consolidate and optimize the below code
for m = 1:length(muscles)               % for each muscle of interest, ...
    muscle = muscles{m};                % name of current muscle
    snippets = Hreflex.extractSnippets( ...
        indsStimArtValid,EMGDataByMuscle(m,:)');
    [amps,rms] = Hreflex.computeAmplitudes(snippets(:,1));
    % convert wave amplitudes from Volts to Millivolts
    amps = cellfun(@(x) 1000.*x,amps,'UniformOutput',false);
    rms = cellfun(@(x) 1000.*x,rms,'UniformOutput',false);

    if any(cellfun(@(x) ~isempty(x),indsNoStimBEMG))
        snippetsNoStimBEMG = Hreflex.extractBackgroundEMG( ...
            indsNoStimBEMG,EMGDataByMuscle(m,:)');
        % compute root mean square of background EMG windows
        rmsNoStimBEMG = cellfun(@(x) 1000.*sqrt(mean(x.^2,2,'omitnan')),...
            snippetsNoStimBEMG,'UniformOutput',false);
        eval(['NoStimBEMGRMSSlow' muscle '(~isStimStrideSlow) = rmsNoStimBEMG{indSlow};']);
        eval(['NoStimBEMGRMSFast' muscle '(~isStimStrideFast) = rmsNoStimBEMG{indFast};']);
    end

    snippetsHreflexBEMG = Hreflex.extractBackgroundEMG( ...
        indsStimArtValid,EMGDataByMuscle(m,:)',opts);
    % compute root mean square of background EMG windows
    rmsHreflexBEMG = cellfun(@(x) 1000.*sqrt(mean(x.^2,2,'omitnan')), ...
        snippetsHreflexBEMG,'UniformOutput',false);

    for l = 1:2                         % for slow (1) & fast (2) leg, ...
        leg = legs{l};                  % name of current leg
        % assign data to correct parameter
        eval(['HwaveAmp' leg muscle '(isStimStride' leg ') = amps{ind' leg ',2};']);
        eval(['MwaveAmp' leg muscle '(isStimStride' leg ') = amps{ind' leg ',1};']);
        eval(['HreflexNoiseAmp' leg muscle '(isStimStride' leg ') = amps{ind' leg ',3};']);
        eval(['H2MAmpRatio' leg muscle '(isStimStride' leg ') = amps{ind' leg ',2} ./ amps{ind' leg ',1};']);
        eval(['HwaveRMS' leg muscle '(isStimStride' leg ') = rms{ind' leg ',2};']);
        eval(['MwaveRMS' leg muscle '(isStimStride' leg ') = rms{ind' leg ',1};']);
        eval(['HreflexNoiseRMS' leg muscle '(isStimStride' leg ') = rms{ind' leg ',3};']);
        eval(['H2MRMSRatio' leg muscle '(isStimStride' leg ') = rms{ind' leg ',2} ./ rms{ind' leg ',1};']);
        eval(['HreflexBEMGRMS' leg muscle '(isStimStride' leg ') = rmsHreflexBEMG{ind' leg '};']);
    end
end

%% Assign Parameters to the Data Matrix
data = nan(length(timeSHS),length(paramLabels));
for ii = 1:length(paramLabels)
    eval(['data(:,ii) = ' paramLabels{ii} ';']);
end

%% Output the Computed Parameters
out = parameterSeries(data,paramLabels,[],description);

end

