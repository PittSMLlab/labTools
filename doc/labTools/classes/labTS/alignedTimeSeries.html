<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of alignedTimeSeries</title>
  <meta name="keywords" content="alignedTimeSeries">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">labTools</a> &gt; <a href="#">classes</a> &gt; <a href="index.html">labTS</a> &gt; alignedTimeSeries.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for labTools/classes/labTS&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>alignedTimeSeries
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function this=alignedTimeSeries(t0,Ts,Data,labels,alignmentVector,alignmentLabels,eventTimes)</a></li><li><a href="#_sub2" class="code">function eET=get.expandedEventTimes(this)</a></li><li><a href="#_sub3" class="code">function this=set.eventTimes(this,eventTimes)</a></li><li><a href="#_sub4" class="code">function newThis=getPartialStridesAsATS(this,inds)</a></li><li><a href="#_sub5" class="code">function newThis=removeStridesWithNaNs(this)</a></li><li><a href="#_sub6" class="code">function newThis=getPartialDataAsATS(this,labels)</a></li><li><a href="#_sub7" class="code">function [figHandle,plotHandles,plottedInds]=plot(this,figHandle,plotHandles,meanColor,events,individualLineStyle,plottedInds,bounds,medianFlag)</a></li><li><a href="#_sub8" class="code">function [meanTS,stds]=mean(this,strideIdxs)</a></li><li><a href="#_sub9" class="code">function newThis=abs(this)</a></li><li><a href="#_sub10" class="code">function [stdTS]=std(this,strideIdxs)</a></li><li><a href="#_sub11" class="code">function [iqrTS]=iqr(this,strideIdxs)</a></li><li><a href="#_sub12" class="code">function [stdTS]=stdRobust(this,strideIdxs)</a></li><li><a href="#_sub13" class="code">function [prctileTS]=prctile(this,p,strideIdxs)</a></li><li><a href="#_sub14" class="code">function medianTS=median(this,strideIdxs)</a></li><li><a href="#_sub15" class="code">function [decomposition,meanValue,avgStride,trial2trialVariability] =energyDecomposition(this)</a></li><li><a href="#_sub16" class="code">function newThis=equalizeEnergyPerChannel(this)</a></li><li><a href="#_sub17" class="code">function newThis=minus(this,other)</a></li><li><a href="#_sub18" class="code">function newThis=plus(this,other)</a></li><li><a href="#_sub19" class="code">function this=times(this,constant)</a></li><li><a href="#_sub20" class="code">function newThis=demean(this)</a></li><li><a href="#_sub21" class="code">function newThis=catStrides(this)</a></li><li><a href="#_sub22" class="code">function [boolFlag,labelIdx]=isaLabel(this,label)</a></li><li><a href="#_sub23" class="code">function newThis=cat(this,other,dim,forceFlag)</a></li><li><a href="#_sub24" class="code">function newThis=castAsTS(this)</a></li><li><a href="#_sub25" class="code">function newThis=concatenateAsTS(this)</a></li><li><a href="#_sub26" class="code">function newThis=fftshift(this,labels)</a></li><li><a href="#_sub27" class="code">function labelList=getLabelsThatMatch(this,exp)</a></li><li><a href="#_sub28" class="code">function newThis=rescaleTime(this,newTs,newT0)</a></li><li><a href="#_sub29" class="code">function this=renameLabels(this,originalLabels,newLabels)</a></li><li><a href="#_sub30" class="code">function newThis=discretize(this,averagingVector)</a></li><li><a href="#_sub31" class="code">function [this,iC,iI]=flipLR(this)</a></li><li><a href="#_sub32" class="code">function [this,iC,iI]=getSym(this)</a></li><li><a href="#_sub33" class="code">function [this,iC,iI]=getaSym(this)</a></li><li><a href="#_sub34" class="code">function [fh,ph]=plotCheckerboard(this,fh,ph)</a></li><li><a href="#_sub35" class="code">function expEventTimes=expandEventTimes(eventTimes,alignmentVector)</a></li><li><a href="#_sub36" class="code">function [histogram,newLabels]=logicalHist(this)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a> <span class="comment">%&lt;labTimeSeries %TODO: make this inherit from labTimeSeries, as it should</span>
0002     <span class="comment">%alignedTimeSeries is a time-series-like object, but where it is</span>
0003     <span class="comment">%assumed that Data stores several repetitions of some recorded set</span>
0004     
0005     properties
0006         Data
0007         Time
0008         labels
0009         alignmentVector=[];
0010         alignmentLabels={};
0011         eventTimes=[];
0012     <span class="keyword">end</span>
0013     
0014     properties(Dependent)
0015         expandedEventTimes
0016     <span class="keyword">end</span>
0017     
0018     methods
0019         <a name="_sub0" href="#_subfunctions" class="code">function this=alignedTimeSeries(t0,Ts,Data,labels,alignmentVector,alignmentLabels,eventTimes)</a>
0020             <span class="comment">%Check:</span>
0021             <span class="keyword">if</span> nargin&lt;6
0022                 warning(<span class="string">'alignedTimeSeries being created without specifying alignment criteria.'</span>)
0023                 alignmentVector=[1];
0024                 alignmentLabels={<span class="string">'Unknown'</span>}; 
0025             <span class="keyword">end</span>
0026             <span class="keyword">if</span> size(Data,2)==length(labels)
0027                 this.Data=Data;
0028                 this.Time=t0+[0:size(Data,1)-1]*Ts;
0029                 this.labels=labels;
0030                 <span class="keyword">if</span> length(alignmentVector)~=length(alignmentLabels)
0031                     error(<span class="string">'alignedTS:Constructor'</span>,<span class="string">'Alignment vector and labels sizes do not match.'</span>)
0032                 <span class="keyword">else</span>
0033                     this.alignmentVector=alignmentVector;
0034                     this.alignmentLabels=alignmentLabels;
0035                 <span class="keyword">end</span>
0036             <span class="keyword">else</span>
0037                 error(<span class="string">'alignedTS:Constructor'</span>,<span class="string">'Data size and label number do not match.'</span>)
0038             <span class="keyword">end</span>
0039             <span class="keyword">if</span> nargin&gt;6 
0040                 this.eventTimes=eventTimes; <span class="comment">%This actually calls on the set() method</span>
0041             <span class="keyword">end</span>
0042         <span class="keyword">end</span>
0043         
0044         <span class="comment">%Getters &amp; setters</span>
0045         <a name="_sub1" href="#_subfunctions" class="code">function eET=get.expandedEventTimes(this)</a>
0046             <span class="keyword">if</span> ~isempty(this.eventTimes)
0047                 eET=alignedTimeSeries.expandEventTimes(this.eventTimes,this.alignmentVector); 
0048             <span class="keyword">else</span> <span class="comment">%legacy version</span>
0049                 error(<span class="string">'eventTimes are not determined'</span>)
0050             <span class="keyword">end</span>
0051         <span class="keyword">end</span>
0052         
0053         <a name="_sub2" href="#_subfunctions" class="code">function this=set.eventTimes(this,eventTimes)</a>
0054             <span class="keyword">if</span> any(size(eventTimes)~=[length(this.alignmentVector) size(this.Data,3)+1])
0055                 error(<span class="string">'alignedTS:SetEventTimes'</span>,<span class="string">'Data and eventTimes sizes do not match.'</span>)
0056             <span class="keyword">else</span>
0057                 this.eventTimes=eventTimes;
0058             <span class="keyword">end</span>
0059         <span class="keyword">end</span>
0060         
0061         <span class="comment">%Other modifiers</span>
0062         <a name="_sub3" href="#_subfunctions" class="code">function newThis=getPartialStridesAsATS(this,inds)</a>
0063             <span class="keyword">if</span> ~isempty(this.eventTimes)
0064 <span class="comment">%                newTimes=this.eventTimes(:,[inds inds(end)+1]); %This can fail if eventTimes was not assigned (not mandatory)</span>
0065                 <span class="keyword">if</span> size(inds,1)==1 <span class="comment">%Changed by DMMO 10/4/2019 the dimmension were not consisten with previous code</span>
0066                     newTimes=this.eventTimes(:,[inds inds(end)+1]); <span class="comment">%This can fail if eventTimes was not assigned (not mandatory)</span>
0067                 <span class="keyword">else</span>
0068                     newTimes=this.eventTimes(:,[inds; inds(end)+1]);
0069                 <span class="keyword">end</span>
0070             <span class="keyword">else</span>
0071                 newTimes=[];
0072             <span class="keyword">end</span>
0073             newThis=<a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a>(this.Time(1),this.Time(2)-this.Time(1),this.Data(:,:,inds),this.labels,this.alignmentVector,this.alignmentLabels,newTimes);
0074         <span class="keyword">end</span>
0075         
0076         <a name="_sub4" href="#_subfunctions" class="code">function newThis=removeStridesWithNaNs(this)</a>
0077            inds=find(all(all(~isnan(this.Data),2),1)); 
0078            newThis=<a href="#_sub4" class="code" title="subfunction newThis=getPartialStridesAsATS(this,inds)">getPartialStridesAsATS</a>(this,inds);
0079         <span class="keyword">end</span>
0080         
0081         <a name="_sub5" href="#_subfunctions" class="code">function newThis=getPartialDataAsATS(this,labels)</a>
0082             [boolIdx,relIdx]=this.isaLabel(labels);
0083             this.Data=this.Data(:,relIdx(boolIdx),:);
0084             this.labels=this.labels(relIdx(boolIdx));
0085             newThis=this;
0086             <span class="comment">%newThis=alignedTimeSeries(this.Time(1),this.Time(2)-this.Time(1),this.Data(:,relIdx(boolIdx),:),this.labels(relIdx(boolIdx)),this.alignmentVector,this.alignmentLabels,this.eventTimes);</span>
0087         <span class="keyword">end</span>
0088         
0089         <a name="_sub6" href="#_subfunctions" class="code">function [figHandle,plotHandles,plottedInds]=plot(this,figHandle,plotHandles,meanColor,events,individualLineStyle,plottedInds,bounds,medianFlag)</a>
0090             <span class="comment">% Plot individual instances (strides) of the time-series, and overlays the mean of all of them</span>
0091             <span class="comment">% Uses one subplot for each label in the timeseries (same as</span>
0092             <span class="comment">% labTimeSeries.plot).</span>
0093             <span class="comment">% If events are given (alignedTimeSeries with the same time vector and number of strides),</span>
0094             <span class="comment">% it will display the average event-time ocurrence in the plot,</span>
0095             <span class="comment">% instead of the time in the x-axis.</span>
0096             <span class="comment">% See also labTimeSeries.plot</span>
0097             <span class="comment">%</span>
0098             <span class="comment">% SYNTAX:</span>
0099             <span class="comment">% [figHandle,plotHandles]=plot(this,figHandle,plotHandles,meanColor,events)</span>
0100             <span class="comment">%</span>
0101             <span class="comment">% INPUTS:</span>
0102             <span class="comment">% this: alignedTimeSeries object to plot</span>
0103             <span class="comment">% figHandle: handle to the figure to be used. If absent,</span>
0104             <span class="comment">% creates a new figure.</span>
0105             <span class="comment">% plotHandles: handles to the subplots being used. There need</span>
0106             <span class="comment">% to be at least as many handles as labels in the data.</span>
0107             <span class="comment">% meanColor: color to use for the plot of the mean. %FIXME</span>
0108             <span class="comment">% events: alignedTimeSeries of events.</span>
0109             <span class="comment">%</span>
0110             <span class="comment">% OUTPUT:</span>
0111             <span class="comment">% figHandle: handle to the figure used.</span>
0112             <span class="comment">% plotHandles: handles to the subplots used.</span>
0113             <span class="comment">%</span>
0114                 <span class="keyword">if</span> nargin&lt;4 || isempty(meanColor)
0115                    meanColor=[1,0,0]; 
0116                 <span class="keyword">end</span>
0117                 <span class="keyword">if</span> nargin&lt;9 || isempty(medianFlag)
0118                     medianFlag=1;
0119                 <span class="keyword">end</span>
0120                 structure=this.Data;
0121                 <span class="keyword">if</span> nargin&lt;2 || isempty(figHandle)
0122                     figHandle=figure();
0123                 <span class="keyword">else</span>
0124                     figure(figHandle) <span class="comment">%Only works for one condition!</span>
0125                 <span class="keyword">end</span>
0126                set(figHandle,<span class="string">'Units'</span>,<span class="string">'normalized'</span>,<span class="string">'OuterPosition'</span>,[0 0 1 1])
0127                M=size(structure,2);
0128                <span class="keyword">if</span> nargin&lt;3 || isempty(plotHandles) || length(plotHandles)&lt;size(this.Data,2)
0129                 [b,a]=getFigStruct(M);
0130                 plotHandles=tight_subplot(b,a,[.02 .02],[.05 .05], [.05 .05]); <span class="comment">%External function</span>
0131                <span class="keyword">end</span>
0132                meanStr=<a href="#_sub8" class="code" title="subfunction [meanTS,stds]=mean(this,strideIdxs)">mean</a>(structure,3);
0133                <span class="keyword">if</span> nargin&lt;7 || isempty(plottedInds)
0134                    plottedInds=1:size(structure,3);
0135                    <span class="keyword">if</span> (numel(structure))&gt;1e7
0136                            P=floor(1e7/numel(structure(:,:,1)));
0137                            warning([<span class="string">'There are too many strides in this condition to plot ('</span> num2str(size(structure,3)) <span class="string">'). Only plotting first '</span> num2str(P) <span class="string">'.'</span>])
0138                            plottedInds=1:P;  
0139                            structure=structure(:,:,plottedInds);
0140                    <span class="keyword">end</span>
0141                <span class="keyword">elseif</span> any(plottedInds&lt;=0) <span class="comment">%Counting from the back</span>
0142                   plottedInds(plottedInds&lt;=0)=size(structure,3)+plottedInds(plottedInds&lt;=0); 
0143                <span class="keyword">end</span>
0144                    
0145                
0146                <span class="comment">%Define centerline plot:</span>
0147                <span class="keyword">if</span> medianFlag==1
0148                    centerline=this.median.castAsTS; <span class="comment">%Could do mean or median</span>
0149                <span class="keyword">else</span>
0150                    centerline=this.mean.castAsTS;
0151                <span class="keyword">end</span>
0152                
0153                <span class="comment">%Plot percentiles (bounds)</span>
0154                <span class="keyword">if</span> nargin&lt;5 || isempty(events)
0155                     events=[];
0156                     meanEvents=[];
0157                <span class="keyword">else</span>
0158                    <span class="keyword">if</span> isa(events,<span class="string">'alignedTimeSeries'</span>)
0159                     [meanEvents,ss]=<a href="#_sub8" class="code" title="subfunction [meanTS,stds]=mean(this,strideIdxs)">mean</a>(events);
0160                     meanEvents=meanEvents.castAsTS;
0161                    <span class="keyword">else</span>
0162                        meanEvents=events;
0163                        ss=[];
0164                    <span class="keyword">end</span>
0165                     [i2,~]=find(meanEvents.Data);
0166                <span class="keyword">end</span>
0167                <span class="keyword">if</span> ~islogical(this.Data) &amp;&amp; nargin&gt;7 &amp;&amp; ~isempty(bounds)
0168                    <span class="keyword">if</span> length(bounds)==2 <span class="comment">%Alt visualization: add patch</span>
0169                        <span class="keyword">if</span> any(bounds)==0
0170                            <span class="keyword">if</span> medianFlag==1
0171                                st=this.stdRobust.castAsTS;
0172                            <span class="keyword">else</span>
0173                                st=this.std.castAsTS;
0174                            <span class="keyword">end</span>
0175                            <span class="keyword">if</span> all(bounds)==0 <span class="comment">%Plots ste</span>
0176                                aux1=centerline+(st.* 1/sqrt(size(this.Data,3))); 
0177                                aux2=centerline-(st .* 1/sqrt(size(this.Data,3)));
0178                            <span class="keyword">else</span> <span class="comment">%Plots std</span>
0179                                aux1=centerline+(st); 
0180                                aux2=centerline-(st); 
0181                            <span class="keyword">end</span>
0182                        <span class="keyword">else</span>
0183                             aux1=<a href="#_sub13" class="code" title="subfunction [prctileTS]=prctile(this,p,strideIdxs)">prctile</a>(this,bounds(1));
0184                             aux2=<a href="#_sub13" class="code" title="subfunction [prctileTS]=prctile(this,p,strideIdxs)">prctile</a>(this,bounds(2));
0185                        <span class="keyword">end</span>
0186                        <span class="keyword">for</span> i=1:M
0187                            subplot(plotHandles(i))
0188                            hold on
0189                            <span class="keyword">if</span> size(aux1.Time,1)==numel(aux1.Time) <span class="comment">%column vector</span>
0190                                megaTime=[aux1.Time; aux1.Time(end:-1:1)];
0191                            <span class="keyword">else</span> <span class="comment">%row vector</span>
0192                                megaTime=[aux1.Time, aux1.Time(end:-1:1)];
0193                            <span class="keyword">end</span>
0194                            megaData=[aux1.Data(:,i);aux2.Data(end:-1:1,i)];
0195                            megaData(isnan(megaData))=0;
0196                            pp=patch(megaTime,megaData,meanColor,<span class="string">'FaceAlpha'</span>,.4,<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>);
0197                            uistack(pp,<span class="string">'bottom'</span>);
0198                            hold off
0199                        <span class="keyword">end</span>
0200                    <span class="keyword">else</span> <span class="comment">%Plot each percentile line</span>
0201                        <span class="keyword">for</span> k=1:length(bounds)
0202                         [figHandle,plotHandles]=<a href="#_sub7" class="code" title="subfunction [figHandle,plotHandles,plottedInds]=plot(this,figHandle,plotHandles,meanColor,events,individualLineStyle,plottedInds,bounds,medianFlag)">plot</a>(this.prctile(bounds(k)).castAsTS,figHandle,[],plotHandles,[],meanColor*.8,.5);
0203                        <span class="keyword">end</span>
0204                    <span class="keyword">end</span>
0205                <span class="keyword">end</span>
0206                
0207                <span class="comment">%PLot mean trace</span>
0208                [figHandle,plotHandles]=<a href="#_sub7" class="code" title="subfunction [figHandle,plotHandles,plottedInds]=plot(this,figHandle,plotHandles,meanColor,events,individualLineStyle,plottedInds,bounds,medianFlag)">plot</a>(centerline,figHandle,[],plotHandles,meanEvents,meanColor); <span class="comment">%Plotting mean data</span>
0209           
0210                <span class="comment">%Plot individual traces</span>
0211                <span class="keyword">for</span> i=1:M <span class="comment">%Go over labels</span>
0212                    <span class="comment">%subplot(b,a,i)</span>
0213                    subplot(plotHandles(i))
0214                    hold on                  
0215                    <span class="comment">%title(aux{1}.(field).labels{i})</span>
0216                    data=squeeze(structure(:,i,:));
0217                    N=size(data,1);
0218                    <span class="keyword">if</span> nargin&lt;6 || isempty(individualLineStyle)
0219                         ppp=<a href="#_sub7" class="code" title="subfunction [figHandle,plotHandles,plottedInds]=plot(this,figHandle,plotHandles,meanColor,events,individualLineStyle,plottedInds,bounds,medianFlag)">plot</a>(this.Time,data,<span class="string">'Color'</span>,[.7,.7,.7]);
0220                         uistack(ppp,<span class="string">'bottom'</span>)
0221                    <span class="keyword">elseif</span> individualLineStyle==0
0222                        <span class="comment">%nop</span>
0223                    <span class="keyword">else</span>
0224                        ppp=<a href="#_sub7" class="code" title="subfunction [figHandle,plotHandles,plottedInds]=plot(this,figHandle,plotHandles,meanColor,events,individualLineStyle,plottedInds,bounds,medianFlag)">plot</a>(this.Time,data,individualLineStyle);
0225                        uistack(ppp,<span class="string">'bottom'</span>)
0226                    <span class="keyword">end</span>
0227                    
0228                    <span class="comment">%plot([0:N-1]/N,meanStr(:,i),'LineWidth',2,'Color',meanColor);</span>
0229                    <span class="comment">%legend(this.labels{i})</span>
0230                    <span class="comment">%maxM(i)=5*norm(data(:))/sqrt(length(data(:)));</span>
0231                    meanM(i)=<a href="#_sub13" class="code" title="subfunction [prctileTS]=prctile(this,p,strideIdxs)">prctile</a>(data(:),50);
0232                    maxM(i)=2*(<a href="#_sub13" class="code" title="subfunction [prctileTS]=prctile(this,p,strideIdxs)">prctile</a>(data(:),99)-meanM(i))+meanM(i)+eps;
0233                    minM(i)=2*(<a href="#_sub13" class="code" title="subfunction [prctileTS]=prctile(this,p,strideIdxs)">prctile</a>(data(:),1)-meanM(i))+meanM(i);
0234                    axis([this.Time(1) this.Time(end) minM(i) maxM(i)])
0235                    hold off
0236                <span class="keyword">end</span>
0237      
0238                <span class="keyword">if</span> ~isempty(events)
0239                    <span class="keyword">for</span> i=1:length(plotHandles) <span class="comment">%For each plot, plot a standard deviation bar indicating how disperse are events with respect to their mean/median (XTick set).</span>
0240                        eventSampPeriod=(events.Time(2)-events.Time(1));
0241                        subplot(plotHandles(i))
0242                        hold on
0243                        <span class="keyword">for</span> j=1:length(ss)
0244                         <a href="#_sub7" class="code" title="subfunction [figHandle,plotHandles,plottedInds]=plot(this,figHandle,plotHandles,meanColor,events,individualLineStyle,plottedInds,bounds,medianFlag)">plot</a>(events.Time(i2(j))+ss(j)*[-1,1]*eventSampPeriod,[0,0],<span class="string">'k'</span>,<span class="string">'LineWidth'</span>,1);
0245                        <span class="keyword">end</span>
0246                        <span class="comment">%axis tight %TO DO: not use axis tight, but find proper axes limits by computing the rms value of the signal, or something like that.</span>
0247                        hold off
0248                    <span class="keyword">end</span>
0249                <span class="keyword">else</span>
0250                    <span class="keyword">for</span> i=1:length(plotHandles) <span class="comment">%For each plot, plot a standard deviation bar indicating how disperse are events with respect to their mean/median (XTick set).</span>
0251                         subplot(plotHandles(i))
0252                         xt=get(gca,<span class="string">'XTick'</span>);
0253                         xt=[this.Time(1)+[0,cumsum(this.alignmentVector)]*(this.Time(end)-this.Time(1))/sum(this.alignmentVector)];
0254                         xtl=[[this.alignmentLabels, this.alignmentLabels(1)]];
0255                         set(gca,<span class="string">'XTick'</span>,xt,<span class="string">'XTickLabel'</span>,xtl)
0256                         set(gca,<span class="string">'xgrid'</span>,<span class="string">'on'</span>)
0257                    <span class="keyword">end</span>
0258                <span class="keyword">end</span>
0259         <span class="keyword">end</span>
0260         
0261         <a name="_sub7" href="#_subfunctions" class="code">function [meanTS,stds]=mean(this,strideIdxs)</a>
0262             <span class="comment">%Computes mean and standard deviation across all the aligned timeSeries.</span>
0263             <span class="comment">%For regular (double/complex) timeseries, mean and std are</span>
0264             <span class="comment">%computed directly from this.Data and each is returned as a</span>
0265             <span class="comment">%timeseries.</span>
0266             <span class="comment">%For logical data (events), it is assumed that all the aligned</span>
0267             <span class="comment">%timeSeries have the same number of true values and in the same order.</span>
0268             <span class="comment">%A histogram is computed for the temporal ocurrences of this</span>
0269             <span class="comment">%values, and a logical TS is returned with events only in the</span>
0270             <span class="comment">%median values given by this histogram. The labels in this TS are</span>
0271             <span class="comment">%as many as events occur in a single TS (this.Data(:,:,1)).</span>
0272             <span class="comment">%The std is returned as a vector of size Nx1.</span>
0273             <span class="keyword">if</span> nargin&gt;1 &amp;&amp; ~isempty(strideIdxs)
0274                 this.Data=this.Data(:,:,strideIdxs);
0275             <span class="keyword">end</span>
0276             <span class="keyword">if</span> ~islogical(this.Data(1))
0277                 <span class="comment">%meanTS=labTimeSeries(nanmean(this.Data,3),this.Time(1),this.Time(2)-this.Time(1),this.labels);</span>
0278                 meanTS=<a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a>(this.Time(1),this.Time(2)-this.Time(1),nanmean(this.Data,3),this.labels,this.alignmentVector,this.alignmentLabels);
0279                 stds=[];
0280             <span class="keyword">else</span> <span class="comment">%Logical timeseries. Will find events and average appropriately. Assuming the SAME number of events per stride, and in the same ORDER. %FIXME: check event order.</span>
0281                 [histogram,newLabels]=<a href="#_sub36" class="code" title="subfunction [histogram,newLabels]=logicalHist(this)">logicalHist</a>(this);
0282                 <span class="comment">%Compute mean/median:</span>
0283                 newData=sparse([],[],false,size(this.Data,1),length(newLabels),size(this.Data,1));
0284                 mH=nanmedian(histogram);
0285                 <span class="keyword">for</span> i=1:size(histogram,2)
0286                     <span class="keyword">if</span> mod(mH(i),1)~=0
0287                         mH(i)=floor(mH(i));
0288                         warning([<span class="string">'Median event '</span> num2str(i) <span class="string">' falls between two samples'</span>])
0289                     <span class="keyword">end</span>
0290                     newData(mH(i),i)=true;
0291                 <span class="keyword">end</span>
0292                 <span class="comment">%meanTS=labTimeSeries(newData,this.Time(1),this.Time(2)-this.Time(1),newLabels);</span>
0293                 meanTS=<a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a>(this.Time(1),this.Time(2)-this.Time(1),newData,newLabels,this.alignmentVector,this.alignmentLabels);
0294                 stds=nanstd(histogram);
0295             <span class="keyword">end</span>
0296         <span class="keyword">end</span>
0297         
0298         <a name="_sub8" href="#_subfunctions" class="code">function newThis=abs(this)</a>
0299            newThis=this;
0300            newThis.Data=<a href="#_sub9" class="code" title="subfunction newThis=abs(this)">abs</a>(this.Data);
0301         <span class="keyword">end</span>
0302         
0303         <a name="_sub9" href="#_subfunctions" class="code">function [stdTS]=std(this,strideIdxs)</a>
0304             <span class="keyword">if</span> nargin&gt;1 &amp;&amp; ~isempty(strideIdxs)
0305                 this.Data=this.Data(:,:,strideIdxs);
0306             <span class="keyword">end</span>
0307             <span class="keyword">if</span> ~islogical(this.Data(1))
0308                 <span class="comment">%stdTS=labTimeSeries(nanstd(this.Data,[],3),this.Time(1),this.Time(2)-this.Time(1),this.labels);</span>
0309                 stdTS=<a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a>(this.Time(1),this.Time(2)-this.Time(1),nanstd(this.Data,[],3),this.labels,this.alignmentVector,this.alignmentLabels);
0310             <span class="keyword">else</span> <span class="comment">%Logical timeseries. Will find events and average appropriately. Assuming the SAME number of events per stride, and in the same ORDER. %FIXME: check event order.</span>
0311                 [histogram,~]=<a href="#_sub36" class="code" title="subfunction [histogram,newLabels]=logicalHist(this)">logicalHist</a>(this);
0312                 stdTS=<a href="#_sub10" class="code" title="subfunction [stdTS]=std(this,strideIdxs)">std</a>(histogram); <span class="comment">%Not really a tS</span>
0313             <span class="keyword">end</span>
0314         <span class="keyword">end</span>
0315         
0316         <a name="_sub10" href="#_subfunctions" class="code">function [iqrTS]=iqr(this,strideIdxs)</a>
0317             <span class="keyword">if</span> nargin&gt;1 &amp;&amp; ~isempty(strideIdxs)
0318                 this.Data=this.Data(:,:,strideIdxs);
0319             <span class="keyword">else</span>
0320                 strideIdxs=[];
0321             <span class="keyword">end</span>
0322             <span class="keyword">if</span> ~islogical(this.Data(1))
0323                 iqrTS=this.prctile(75) - this.prctile(25);
0324             <span class="keyword">else</span> <span class="comment">%Logical timeseries. Will find events and average appropriately. Assuming the SAME number of events per stride, and in the same ORDER. %FIXME: check event order.</span>
0325                 [histogram,~]=<a href="#_sub36" class="code" title="subfunction [histogram,newLabels]=logicalHist(this)">logicalHist</a>(this);
0326                 iqrTS=<a href="#_sub11" class="code" title="subfunction [iqrTS]=iqr(this,strideIdxs)">iqr</a>(histogram); <span class="comment">%Not really a tS</span>
0327             <span class="keyword">end</span>
0328         <span class="keyword">end</span>
0329         
0330         <a name="_sub11" href="#_subfunctions" class="code">function [stdTS]=stdRobust(this,strideIdxs)</a>
0331             <span class="keyword">if</span> nargin&gt;1 &amp;&amp; ~isempty(strideIdxs)
0332                 this.Data=this.Data(:,:,strideIdxs);
0333             <span class="keyword">end</span>
0334             <span class="comment">%IQR-based std computation</span>
0335             stdTS=this.iqr .* (1/1.35);
0336         <span class="keyword">end</span>
0337         
0338         <a name="_sub12" href="#_subfunctions" class="code">function [prctileTS]=prctile(this,p,strideIdxs)</a>
0339             <span class="keyword">if</span> nargin&gt;2 &amp;&amp; ~isempty(strideIdxs)
0340                 this.Data=this.Data(:,:,strideIdxs);
0341             <span class="keyword">end</span>
0342             <span class="keyword">if</span> ~islogical(this.Data(1))
0343                 <span class="comment">%prctileTS=labTimeSeries(prctile(this.Data,p,3),this.Time(1),this.Time(2)-this.Time(1),this.labels);</span>
0344                 prctileTS=<a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a>(this.Time(1),this.Time(2)-this.Time(1),<a href="#_sub13" class="code" title="subfunction [prctileTS]=prctile(this,p,strideIdxs)">prctile</a>(this.Data,p,3),this.labels,this.alignmentVector,this.alignmentLabels);
0345             <span class="keyword">else</span> <span class="comment">%Logical timeseries.</span>
0346                 error(<span class="string">'alignedTimeSeries:prctile'</span>,<span class="string">'Prctile not yet implemented for logical alignedTimeSeries.'</span>) <span class="comment">%TODO</span>
0347             <span class="keyword">end</span> 
0348         <span class="keyword">end</span>
0349         
0350         <a name="_sub13" href="#_subfunctions" class="code">function medianTS=median(this,strideIdxs)</a>
0351             <span class="keyword">if</span> nargin&lt;2 || isempty(strideIdxs)
0352                 strideIdxs=[];
0353             <span class="keyword">end</span>
0354             [medianTS]=<a href="#_sub13" class="code" title="subfunction [prctileTS]=prctile(this,p,strideIdxs)">prctile</a>(this,50,strideIdxs);
0355         <span class="keyword">end</span>
0356         
0357         <a name="_sub14" href="#_subfunctions" class="code">function [decomposition,meanValue,avgStride,trial2trialVariability] =energyDecomposition(this)</a>
0358             alignedData=this.Data;
0359             [decomposition,meanValue,avgStride,trial2trialVariability] = getVarianceDecomposition(alignedData);
0360         <span class="keyword">end</span>
0361         
0362         <a name="_sub15" href="#_subfunctions" class="code">function newThis=equalizeEnergyPerChannel(this)</a>
0363             newThis=this;
0364             newThis.Data=bsxfun(@rdivide,newThis.Data,sqrt(<a href="#_sub8" class="code" title="subfunction [meanTS,stds]=mean(this,strideIdxs)">mean</a>(<a href="#_sub8" class="code" title="subfunction [meanTS,stds]=mean(this,strideIdxs)">mean</a>(this.Data.^2,3),1)));
0365         <span class="keyword">end</span>
0366         
0367         <a name="_sub16" href="#_subfunctions" class="code">function newThis=minus(this,other)</a>
0368            newThis=this;
0369            newThis.Data=this.Data-other.Data;
0370         <span class="keyword">end</span>
0371         
0372         <a name="_sub17" href="#_subfunctions" class="code">function newThis=plus(this,other)</a>
0373            newThis=this;
0374            newThis.Data=this.Data+other.Data;
0375         <span class="keyword">end</span>
0376         
0377         <a name="_sub18" href="#_subfunctions" class="code">function this=times(this,constant)</a>
0378             this.Data=this.Data .* constant;
0379             <span class="keyword">if</span> numel(constant)==1
0380                 s=num2str(constant);
0381             <span class="keyword">else</span>
0382                 s=<span class="string">'k'</span>; <span class="comment">%Generic constant string</span>
0383             <span class="keyword">end</span>
0384             this.labels=strcat([s <span class="string">'*'</span>],this.labels);
0385         <span class="keyword">end</span>
0386         
0387         <a name="_sub19" href="#_subfunctions" class="code">function newThis=demean(this)</a>
0388             newThis=this;
0389             newThis.Data=bsxfun(@<a href="#_sub17" class="code" title="subfunction newThis=minus(this,other)">minus</a>,this.Data,this.mean.Data);
0390         <span class="keyword">end</span>
0391         
0392         <a name="_sub20" href="#_subfunctions" class="code">function newThis=catStrides(this)</a>
0393             auxData=permute(this.Data,[2,1,3]);
0394             newThis=labTimeSeries(auxData(:,:)',this.Time(1),this.Time(2)-this.Time(1),this.labels);
0395         <span class="keyword">end</span>
0396         
0397         <a name="_sub21" href="#_subfunctions" class="code">function [boolFlag,labelIdx]=isaLabel(this,label)</a>
0398             boolFlag=false(size(label));
0399             labelIdx=zeros(size(label));
0400             [bool,idx] = compareListsFast(label,this.labels);
0401             <span class="keyword">for</span> j=1:length(label)
0402                 <span class="keyword">if</span> any(idx==j)
0403                     boolFlag(j)=true;
0404                     labelIdx(j)=find(idx==j);
0405                 <span class="keyword">end</span>
0406             <span class="keyword">end</span>
0407         <span class="keyword">end</span>
0408         
0409         <a name="_sub22" href="#_subfunctions" class="code">function newThis=cat(this,other,dim,forceFlag)</a>
0410             <span class="keyword">if</span> nargin&lt;4
0411                 forceFlag=false;
0412             <span class="keyword">end</span>
0413             <span class="keyword">if</span> nargin&lt;3 || isempty(dim)
0414                 dim=3;<span class="comment">%Cat-ting strides</span>
0415             <span class="keyword">end</span>
0416             
0417             <span class="comment">%Check alignment vectors coincide &amp; alignment labels coincide</span>
0418             <span class="keyword">if</span> any(this.alignmentVector~=other.alignmentVector)
0419                 ME=MException(<span class="string">'ATS:cat'</span>,<span class="string">'Alignment vector mismatch'</span>);
0420                 throw(ME);
0421             <span class="keyword">end</span>
0422             <span class="keyword">if</span> ~forceFlag &amp;&amp; ~all(strcmp(this.alignmentLabels,other.alignmentLabels))
0423                 ME=MException(<span class="string">'ATS:cat'</span>,<span class="string">'Alignment labels mismatch, this check can be ignored by setting forceFlag=true'</span>);
0424                 throw(ME);
0425             <span class="keyword">end</span>
0426             
0427             <span class="keyword">if</span> dim==3
0428             <span class="comment">%Check dimensions coincide</span>
0429             s1=size(this.Data);
0430             s2=size(other.Data);
0431             <span class="keyword">if</span> any(s1(1:2)~=s2(1:2))
0432                 ME=MException(<span class="string">'ATS:cat'</span>,<span class="string">'Data dimension mismatch.'</span>);
0433                 throw(ME);
0434             <span class="keyword">end</span>
0435 
0436             <span class="comment">%Check labels coincide (unless forced)</span>
0437             <span class="keyword">if</span> ~forceFlag &amp;&amp; ~all(strcmp(this.labels,other.labels))
0438                 ME=MException(<span class="string">'ATS:cat'</span>,<span class="string">'Label mismatch, this check can be ignored by setting forceFlag=true'</span>);
0439                 throw(ME);
0440             <span class="keyword">end</span>
0441             
0442             <span class="comment">%Do the cat:</span>
0443             newThis=<a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a>(this.Time(1),diff(this.Time(1:2)),<a href="#_sub23" class="code" title="subfunction newThis=cat(this,other,dim,forceFlag)">cat</a>(3,this.Data,other.Data),this.labels,this.alignmentVector,this.alignmentLabels,<a href="#_sub23" class="code" title="subfunction newThis=cat(this,other,dim,forceFlag)">cat</a>(2,this.eventTimes(:,1:end-1),other.eventTimes));
0444             warning(<span class="string">'ATS:catStridesLostEvents'</span>,<span class="string">'Cat-ting strides of alignedTimeSeries, events are no longer consecutive.'</span>)
0445             <span class="keyword">elseif</span> dim==2 <span class="comment">%Cat-ting labels</span>
0446                 <span class="comment">%Check dimensions coincide</span>
0447                 s1=size(this.Data);
0448                 s2=size(other.Data);
0449                 <span class="keyword">if</span> any(s1([1,3])~=s2([1,3]))
0450                     ME=MException(<span class="string">'ATS:cat'</span>,<span class="string">'Data dimension mismatch.'</span>);
0451                     throw(ME);
0452                 <span class="keyword">end</span>
0453                 <span class="comment">%Check no repeated labels</span>
0454             
0455                 <span class="comment">%Check alignmentVector &amp; Labels</span>
0456                 
0457                 <span class="comment">%Check that all eventTimes match</span>
0458                 <span class="keyword">if</span> any(size(this.eventTimes)~=size(other.eventTimes)) || any(<a href="#_sub9" class="code" title="subfunction newThis=abs(this)">abs</a>(this.eventTimes(:)-other.eventTimes(:))&gt;1e-9)
0459                    ME=MException(<span class="string">'ATS:cat'</span>,<span class="string">'Trying to cat labels, but event times are different'</span>);
0460                    throw(ME);
0461                 <span class="keyword">end</span>
0462             
0463                 <span class="comment">%Do the cat</span>
0464                 newThis=<a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a>(this.Time(1),diff(this.Time(1:2)),<a href="#_sub23" class="code" title="subfunction newThis=cat(this,other,dim,forceFlag)">cat</a>(2,this.Data,other.Data),[this.labels,other.labels],this.alignmentVector,this.alignmentLabels,this.eventTimes);
0465             <span class="keyword">else</span>
0466                 ME=MException();
0467                 throw(ME);
0468             <span class="keyword">end</span>
0469         <span class="keyword">end</span>
0470         
0471         <a name="_sub23" href="#_subfunctions" class="code">function newThis=castAsTS(this)</a>
0472            <span class="comment">%Function to change the class to labTS (instead of ATS). This is a temp function, until alignedTS is changed to inherit from labTS</span>
0473            <span class="keyword">if</span> size(this.Data,3)&gt;1
0474                ME=MException(<span class="string">'alignedTS:castAsTS'</span>,<span class="string">'To cast as TS, there may be a single alignedTS (i.e. size(this.Data,3)==1)'</span>);
0475                throw(ME)
0476            <span class="keyword">end</span>
0477            newThis=labTimeSeries(this.Data,this.Time(1),this.Time(2)-this.Time(1),this.labels);
0478         <span class="keyword">end</span>
0479         
0480         <a name="_sub24" href="#_subfunctions" class="code">function newThis=concatenateAsTS(this)</a>
0481             <span class="comment">%This concatenates the ATS by putting strides one after another</span>
0482             <span class="comment">%in time, returning a single labTS</span>
0483            newThis=labTimeSeries(reshape(permute(this.Data,[1,3,2]),[size(this.Data,1)*size(this.Data,3),size(this.Data,2)]),this.Time(1),this.Time(2)-this.Time(1),this.labels);
0484         <span class="keyword">end</span>
0485         
0486         <a name="_sub25" href="#_subfunctions" class="code">function newThis=fftshift(this,labels)</a>
0487             <span class="comment">%Shifts the first and second halves of the alignment cycle</span>
0488             <span class="comment">%Example, if the first half starts at FHS and second half</span>
0489             <span class="comment">%starts at SHS, the shifted version will start at SHS and FHS</span>
0490             <span class="comment">%will be the midpoint of the cycle.</span>
0491             <span class="keyword">if</span> nargin&gt;1 &amp;&amp; ~isempty(labels)
0492                 [~,idxs]=this.isaLabel(labels);
0493             <span class="keyword">else</span>
0494                 idxs=1:length(this.labels);
0495             <span class="keyword">end</span>
0496            newThis=this;
0497            M=round(length(this.alignmentVector)/2);
0498            N=sum(this.alignmentVector(1:M));
0499            newThis.Data(:,idxs,:)=this.Data([N+1:size(this.Data,1),1:N],idxs,:);
0500         <span class="keyword">end</span>
0501         
0502         <a name="_sub26" href="#_subfunctions" class="code">function labelList=getLabelsThatMatch(this,exp)</a>
0503             <span class="comment">%Returns labels on this labTS that match the regular expression exp.</span>
0504             <span class="comment">%labelList=getLabelsThatMatch(this,exp)</span>
0505             <span class="comment">%INPUT:</span>
0506             <span class="comment">%this: labTS object</span>
0507             <span class="comment">%exp: any regular expression (as string).</span>
0508             <span class="comment">%OUTPUT:</span>
0509             <span class="comment">%labelList: cell array containing labels of this labTS that match</span>
0510             <span class="comment">%See also regexp</span>
0511             labelList=this.labels; 
0512             flags=cellfun(@(x) ~isempty(x),regexp(labelList,exp));
0513             labelList=labelList(flags);
0514         <span class="keyword">end</span>
0515         
0516         <a name="_sub27" href="#_subfunctions" class="code">function newThis=rescaleTime(this,newTs,newT0)</a>
0517             <span class="comment">%Re-defines the Time vector to force a new sampling time</span>
0518             <span class="comment">%Made for backwards compatibility of aligned series always</span>
0519             <span class="comment">%being defined with time in [0 1]</span>
0520             <span class="keyword">if</span> nargin&lt;3 || isempty(newT0)
0521                 newT0=0;
0522             <span class="keyword">end</span>
0523             <span class="keyword">if</span> nargin&lt;2 || isempty(newTs)
0524                 newTs=1/length(this.Time); <span class="comment">%Re-scales such that total duration is 1 [time can be thought of as % of some cycle]</span>
0525             <span class="keyword">end</span>
0526             newThis=<a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a>(newT0,newTs,this.Data,this.labels,this.alignmentVector,this.alignmentLabels);
0527         <span class="keyword">end</span>
0528         
0529         <a name="_sub28" href="#_subfunctions" class="code">function this=renameLabels(this,originalLabels,newLabels)</a>
0530             warning(<span class="string">'labTS:renameLabels:dont'</span>,<span class="string">'You should not be renaming the labels. You have been warned.'</span>)
0531             <span class="keyword">if</span> isempty(originalLabels)
0532                 originalLabels=this.labels;
0533             <span class="keyword">end</span>
0534             <span class="keyword">if</span> size(newLabels)~=size(originalLabels)
0535                 error(<span class="string">'Inconsistent label sizes'</span>)
0536             <span class="keyword">end</span>
0537             [boo,idx]=this.isaLabel(originalLabels);
0538             this.labels(idx(boo))=newLabels;
0539         <span class="keyword">end</span>
0540         
0541         <a name="_sub29" href="#_subfunctions" class="code">function newThis=discretize(this,averagingVector)</a>
0542             <span class="keyword">if</span> sum(averagingVector)~=sum(this.alignmentVector)
0543                 error(<span class="string">'The averaging vector must sum to the number of samples of the alignedTS'</span>)
0544             <span class="keyword">end</span>
0545             lastInd=0;
0546             newData=nan(length(averagingVector),size(this.Data,2),size(this.Data,3));
0547             expEventTimes=alignedTimeSeries.expandEventTimes(this.eventTimes,this.alignmentVector);
0548             newEventTimes=nan(length(averagingVector),size(expEventTimes,2)+1);
0549             auxSamp=1+[0 cumsum(this.alignmentVector)];
0550             <span class="keyword">for</span> i=1:length(averagingVector)
0551                 inds=lastInd+[1:averagingVector(i)];
0552                 newData(i,:,:)=nanmean(this.Data(inds,:,:));
0553                 <span class="keyword">if</span> ~any(auxSamp==inds(1))
0554                     aux1=<span class="string">'-'</span>;
0555                 <span class="keyword">else</span>
0556                     aux1=this.alignmentLabels{auxSamp==inds(1)};
0557                 <span class="keyword">end</span>
0558                 <span class="keyword">if</span> ~any(auxSamp==inds(end))
0559                     aux2=<span class="string">'-'</span>;
0560                 <span class="keyword">else</span>
0561                     aux2=this.alignmentLabels{auxSamp==inds(end)};
0562                 <span class="keyword">end</span>
0563                 aux=this.alignmentLabels(auxSamp&gt;inds(1) &amp; auxSamp&lt;inds(end));
0564                 <span class="keyword">if</span> ~isempty(aux)
0565                     auxM=cell2mat(aux);
0566                 <span class="keyword">else</span>
0567                     auxM=<span class="string">'-'</span>;
0568                 <span class="keyword">end</span>
0569                 alignLabel{i}=[aux1 aux2];
0570                 newEventTimes(i,1:end-1)=expEventTimes(lastInd+1,:); <span class="comment">%Beginning of averaged interval</span>
0571                 lastInd=lastInd+averagingVector(i);
0572             <span class="keyword">end</span>
0573             newEventTimes(1,end)=this.eventTimes(1,end);
0574             newThis=<a href="alignedTimeSeries.html" class="code" title="">alignedTimeSeries</a>(0,1,newData,this.labels,ones(size(averagingVector)),alignLabel,newEventTimes);
0575         <span class="keyword">end</span>
0576         
0577         <a name="_sub30" href="#_subfunctions" class="code">function [this,iC,iI]=flipLR(this)</a>
0578            <span class="comment">%Find the side that has the starting event:</span>
0579            alignedSide=this.alignmentLabels{1}(1);
0580            nonAlignedSide=getOtherLeg(alignedSide);
0581            <span class="comment">%Flip non-aligned side:</span>
0582            lC=this.getLabelsThatMatch([<span class="string">'^'</span> nonAlignedSide]); <span class="comment">%Get non-aligned side labels</span>
0583            <span class="keyword">if</span> ~isempty(lC)
0584                [~,iC]=this.isaLabel(lC); <span class="comment">%Index for non-aligned</span>
0585                aux=regexprep(lC,[<span class="string">'^'</span> nonAlignedSide],alignedSide); <span class="comment">%Getting aligned side labels</span>
0586                [bI,iI]=this.isaLabel(aux); <span class="comment">%Index for aligned</span>
0587                <span class="keyword">if</span> ~all(bI) <span class="comment">%Labels are not symm, aborting</span>
0588                    warning(<span class="string">'Asked to flipLR but labels are not symmetrically present.'</span>)
0589                <span class="keyword">else</span>
0590                    this.Data(:,iC)=<a href="#_sub26" class="code" title="subfunction newThis=fftshift(this,labels)">fftshift</a>(this.Data(:,iC),1); <span class="comment">%This just flips first and second halves of aligned data, no checks performed</span>
0591                    this.alignmentLabels=regexprep(this.alignmentLabels,[<span class="string">'^'</span> alignedSide],<span class="string">'i'</span>);
0592                    this.alignmentLabels=regexprep(this.alignmentLabels,[<span class="string">'^'</span> nonAlignedSide],<span class="string">'c'</span>);
0593                <span class="keyword">end</span>
0594            <span class="keyword">else</span>
0595                 warning(<span class="string">'Asked to flipLR but couldn''t find aligned side.'</span>)
0596                 iC=[];
0597            <span class="keyword">end</span>
0598         <span class="keyword">end</span>
0599         
0600         <a name="_sub31" href="#_subfunctions" class="code">function [this,iC,iI]=getSym(this)</a>
0601             [this,iC,iI]=this.flipLR; <span class="comment">%First, flip the non-aligned side.</span>
0602             <span class="comment">%Then: compute sym/asym data and replace it.</span>
0603             this.Data=[this.Data(:,iI)-this.Data(:,iC) this.Data(:,iI)+this.Data(:,iC)];
0604             <span class="comment">%Update labels:</span>
0605             this.labels=[regexprep(this.labels(iI),[<span class="string">'^'</span> this.labels{iI(1)}(1)],<span class="string">'a'</span>) regexprep(this.labels(iI),[<span class="string">'^'</span> this.labels{iI(1)}(1)],<span class="string">'b'</span>)];
0606       
0607         <span class="keyword">end</span>
0608         
0609         
0610         <a name="_sub32" href="#_subfunctions" class="code">function [this,iC,iI]=getaSym(this)</a>
0611             [this,iC,iI]=this.flipLR; <span class="comment">%First, flip the non-aligned side.</span>
0612             <span class="comment">%Then: compute asym data and replace it.</span>
0613             this.Data=[this.Data(:,iI)-this.Data(:,iC)]; <span class="comment">%we do slow - fast here</span>
0614             <span class="comment">%Update labels:</span>
0615             this.labels=[regexprep(this.labels(iI),[<span class="string">'^'</span> this.labels{iI(1)}(1)],<span class="string">'a'</span>)];
0616             
0617         <span class="keyword">end</span>
0618                 
0619         
0620         <a name="_sub33" href="#_subfunctions" class="code">function [fh,ph]=plotCheckerboard(this,fh,ph)</a>
0621            <span class="keyword">if</span> nargin&lt;2
0622                fh=figure();
0623            <span class="keyword">else</span>
0624                figure(fh);
0625            <span class="keyword">end</span>
0626            <span class="keyword">if</span> nargin&lt;3
0627                ph=gca;
0628            <span class="keyword">else</span>
0629                axes(ph);
0630            <span class="keyword">end</span>
0631            m=this.mean;
0632            <span class="comment">%imagesc(m.Data')</span>
0633            surf([this.Time, 2*this.Time(end)-this.Time(end-1)],[0:size(m.Data,2)],[[m.Data';m.Data(:,end)'],[m.Data(<span class="keyword">end</span>,:)';0]],<span class="string">'EdgeColor'</span>,<span class="string">'none'</span>)
0634            view(2)
0635            ax=gca;
0636            ax.YTick=[1:length(this.labels)]-.5;
0637            ax.YTickLabels=this.labels;
0638            ax.XTick=[.5 .5+cumsum(this.alignmentVector)]/sum(this.alignmentVector) *this.Time(end) ;
0639            ax.XTickLabel=this.alignmentLabels;
0640            axis([this.Time(1) 2*this.Time(end)-this.Time(end-1) 0 size(m.Data,2)])
0641            <span class="comment">%Colormap:</span>
0642             ex2=[0.2314    0.2980    0.7529];
0643             ex1=[0.7255    0.0863    0.1608];
0644             gamma=.5;
0645             map=[bsxfun(@<a href="#_sub18" class="code" title="subfunction newThis=plus(this,other)">plus</a>,ex1.^(1/gamma),bsxfun(@<a href="#_sub19" class="code" title="subfunction this=times(this,constant)">times</a>,1-ex1.^(1/gamma),[0:.01:1]'));bsxfun(@<a href="#_sub18" class="code" title="subfunction newThis=plus(this,other)">plus</a>,ex2.^(1/gamma),bsxfun(@<a href="#_sub19" class="code" title="subfunction this=times(this,constant)">times</a>,1-ex2.^(1/gamma),[1:-.01:0]'))].^gamma;
0646 
0647             colormap(flipud(map))
0648             <span class="keyword">try</span>
0649             caxis([-1 1]*max(<a href="#_sub9" class="code" title="subfunction newThis=abs(this)">abs</a>(m.Data(:)))) <span class="comment">%Fails if plotted data is NaN</span>
0650             colorbar
0651             <span class="keyword">catch</span>
0652                 
0653             <span class="keyword">end</span>
0654             
0655             <span class="comment">%To do: check if the events exist, and add DS/STANCE/DS/SWING labels</span>
0656         <span class="keyword">end</span>
0657     <span class="keyword">end</span>
0658     
0659     methods (Static)
0660         <a name="_sub34" href="#_subfunctions" class="code">function expEventTimes=expandEventTimes(eventTimes,alignmentVector)</a>
0661             <span class="comment">%Given event times and an alignment vectors, this function</span>
0662             <span class="comment">%computes the corresponding time for each sample in an</span>
0663             <span class="comment">%alignedTimeSeries, provided that the sampling is uniform</span>
0664             <span class="comment">%between events.</span>
0665             <span class="comment">%This method cannot be hiddent because it is used in labTS</span>
0666             
0667             refTime=1+[0 cumsum(alignmentVector)]'; <span class="comment">%This should be 0+ for the old-style alignment</span>
0668             M=size(eventTimes,2)-1;
0669             N=sum(alignmentVector);
0670             allEventTimes=eventTimes(:);
0671             refTime2=bsxfun(@<a href="#_sub18" class="code" title="subfunction newThis=plus(this,other)">plus</a>,refTime(1:end-1),N*[0:M]);
0672             allExpEventTimes=interp1(refTime2(:),allEventTimes(:),[1:N*M]');
0673             expEventTimes=reshape(allExpEventTimes,N,M);
0674            
0675         <span class="keyword">end</span>
0676     <span class="keyword">end</span>
0677     
0678     methods(Hidden)
0679         <a name="_sub35" href="#_subfunctions" class="code">function [histogram,newLabels]=logicalHist(this)</a>
0680             <span class="comment">%Generates a histogram from the logical data (true/false) contained in this alignedTS. Assumes that all aligned TS contain the same events, in the same order.</span>
0681             
0682             <span class="comment">%Check: this is a logical alignedTS</span>
0683             <span class="comment">%TODO</span>
0684             <span class="comment">%TODO: dtermine the number of expected events. Currently this</span>
0685             <span class="comment">%is as many events as stride 1 has. May be problematic if</span>
0686             <span class="comment">%stride one is invalid.</span>
0687             aaux=cellfun(@(x) isempty(x),strfind(this.labels,<span class="string">'force'</span>)) &amp; cellfun(@(x) isempty(x),strfind(this.labels,<span class="string">'kin'</span>));
0688             eventNo=mode(sum(sum(this.Data(:,aaux),1),2)); <span class="comment">%Mode of the # of events per stride, assuming this is what should happen on every stride.</span>
0689             nStrides=size(this.Data,3);
0690             eventType=nan(eventNo,1);
0691             <span class="keyword">for</span> i=1:eventNo
0692                 aux=nan(nStrides,1);
0693                 <span class="keyword">for</span> k=1:nStrides <span class="comment">%Going over strides</span>
0694                     eventIdx=find(sum(this.Data(:,aaux,k),2)==1,i,<span class="string">'first'</span>); <span class="comment">%Time index of first i events in stride k</span>
0695                     <span class="keyword">if</span> length(eventIdx)==i <span class="comment">%Checking that I found i events</span>
0696                         aux(k)=find(this.Data(eventIdx(i),aaux,k),1,<span class="string">'first'</span>);
0697                     <span class="keyword">end</span>
0698                 <span class="keyword">end</span>
0699                 eventType(i)=round(nanmedian(aux)); <span class="comment">%Rounding is to break possible ties (very unlikely)</span>
0700             <span class="keyword">end</span>
0701             histogram=nan(nStrides,eventNo);
0702             ii=eventType;
0703             aux=zeros(eventNo,1);
0704             newLabels=cell(size(ii));
0705             <span class="keyword">for</span> i=1:length(ii)
0706                 aux(ii(i))=aux(ii(i))+1;
0707                 <span class="keyword">if</span> aux(ii(i))==1
0708                     newLabels{i}=this.labels{ii(i)};
0709                 <span class="keyword">else</span>
0710                     newLabels{i}=[this.labels{ii(i)} num2str(aux(ii(i)))];
0711                 <span class="keyword">end</span>
0712             <span class="keyword">end</span>
0713 
0714             <span class="keyword">for</span> i=1:nStrides
0715                 [eventTimeIndex,eventType]=find(this.Data(:,aaux,i));
0716                 <span class="keyword">if</span> length(eventTimeIndex)~=length(newLabels)
0717                     warning([<span class="string">'alignedTS:logicalHist: Stride '</span> num2str(i) <span class="string">' has more or less events than expected (expecting '</span> num2str(length(newLabels)) <span class="string">', but got '</span> num2str(length(eventTimeIndex)) <span class="string">'). Discarding.'</span>]);
0718                     histogram(i,:)=nan;
0719                 <span class="keyword">else</span>
0720                     <span class="comment">%FIXME: check event order by using the labels.</span>
0721                     [eventTimeIndex,auxInds]=sort(eventTimeIndex);
0722                     <span class="keyword">if</span> all(ii==eventType(auxInds))
0723                         histogram(i,:)=eventTimeIndex;
0724                     <span class="keyword">else</span>
0725                         warning([<span class="string">'alignedTS:logicalHist: Stride '</span> num2str(i) <span class="string">' has events in different order than expected (expecting '</span> num2str(ii') <span class="string">', but got '</span> num2str(eventType(auxInds)') <span class="string">'). Discarding.'</span>]);
0726                     <span class="keyword">end</span>
0727                 <span class="keyword">end</span>
0728             <span class="keyword">end</span>
0729         <span class="keyword">end</span>
0730     <span class="keyword">end</span>
0731 <span class="keyword">end</span>
0732</pre></div>
<hr><address>Generated on Thu 06-Jun-2024 12:15:54 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>