<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of labTimeSeries</title>
  <meta name="keywords" content="labTimeSeries">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../../index.html">Home</a> &gt;  <a href="#">labTools</a> &gt; <a href="#">classes</a> &gt; <a href="../index.html">labTS</a> &gt; <a href="index.html">@labTimeSeries</a> &gt; labTimeSeries.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../../index.html"><img alt="<" border="0" src="../../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for labTools/classes/labTS/@labTimeSeries&nbsp;<img alt=">" border="0" src="../../../../right.png"></a></td></tr></table>-->

<h1>labTimeSeries
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function this=labTimeSeries(data,t0,Ts,labels)</a></li><li><a href="#_sub2" class="code">function [data,time,auxLabel]=getDataAsVector(this,label)</a></li><li><a href="#_sub3" class="code">function [newTS,auxLabel]=getDataAsTS(this,label)</a></li><li><a href="#_sub4" class="code">function labelList=getLabels(this)</a></li><li><a href="#_sub5" class="code">function this=renameLabels(this,originalLabels,newLabels)</a></li><li><a href="#_sub6" class="code">function labelList=getLabelsThatMatch(this,exp)</a></li><li><a href="#_sub7" class="code">function [boolFlag,labelIdx]=isaLabel(this,label)</a></li><li><a href="#_sub8" class="code">function data=getSample(this,timePoints,method)</a></li><li><a href="#_sub9" class="code">function newTS=synchTo(this,otherTS)</a></li><li><a href="#_sub10" class="code">function index=getIndexClosestToTimePoint(this,timePoints)</a></li><li><a href="#_sub11" class="code">function newThis=resample(this,newTs,newT0,hiddenFlag)</a></li><li><a href="#_sub12" class="code">function newThis=resampleN(this,newN,method)</a></li><li><a href="#_sub13" class="code">function newThis=split(this,t0,t1)</a></li><li><a href="#_sub14" class="code">function newThis=appendData(this,newData,newLabels)</a></li><li><a href="#_sub15" class="code">function [newThis,newData]=addNewParameter(this,newParamLabel,funHandle,inputParameterLabels)</a></li><li><a href="#_sub16" class="code">function [newData]=computeNewParameter(this,newParamLabel,funHandle,inputParameterLabels)</a></li><li><a href="#_sub17" class="code">function newThis=removeParameter(labels)</a></li><li><a href="#_sub18" class="code">function newThis=castAsOTS(this,orientation)</a></li><li><a href="#_sub19" class="code">function newThis=castAsSTS(this,F,tWin,tOverlap)</a></li><li><a href="#_sub20" class="code">function [data,time,auxLabel]=getPartialDataAsVector(this,label,t0,t1)</a></li><li><a href="#_sub21" class="code">function [steppedDataArray,bad,initTime,eventTimes]=splitByEvents(this,eventTS,eventLabel,timeMargin)</a></li><li><a href="#_sub22" class="code">function [slicedTS,initTime,duration]=sliceTS(this,timeBreakpoints,timeMargin)</a></li><li><a href="#_sub23" class="code">function this=times(this,constant)</a></li><li><a href="#_sub24" class="code">function this=rectify(this)</a></li><li><a href="#_sub25" class="code">function newThis=plus(this,other)</a></li><li><a href="#_sub26" class="code">function newThis=minus(this,other)</a></li><li><a href="#_sub27" class="code">function newThis=derivate(this)</a></li><li><a href="#_sub28" class="code">function [newThis,lag]=derivative(this,diffOrder)</a></li><li><a href="#_sub29" class="code">function newThis=integrate(this,initValues)</a></li><li><a href="#_sub30" class="code">function newthis=equalizeEnergyPerChannel(this)</a></li><li><a href="#_sub31" class="code">function newthis=equalizeVarPerChannel(this)</a></li><li><a href="#_sub32" class="code">function newthis=demean(this)</a></li><li><a href="#_sub33" class="code">function this=fillts(this)</a></li><li><a href="#_sub34" class="code">function newThis=concatenate(this,other)</a></li><li><a href="#_sub35" class="code">function newThis=cat(this,other)</a></li><li><a href="#_sub36" class="code">function this=substituteNaNs(this,method)</a></li><li><a href="#_sub37" class="code">function newThis=thresholdByChannel(this,th,label,moreThanFlag)</a></li><li><a href="#_sub38" class="code">function fs=get.sampFreq(this)</a></li><li><a href="#_sub39" class="code">function tr=get.timeRange(this)</a></li><li><a href="#_sub40" class="code">function Nsamp=get.Nsamples(this)</a></li><li><a href="#_sub41" class="code">function [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth)</a></li><li><a href="#_sub42" class="code">function [h,plotHandles]=plotAligned(this,h,labels,plotHandles,events,color,lineWidth)</a></li><li><a href="#_sub43" class="code">function [h,plotHandles]=bilateralPlot(this,h,labels,plotHandles,events,color,lineWidth)</a></li><li><a href="#_sub44" class="code">function h=dispCov(this)</a></li><li><a href="#_sub45" class="code">function [fh,ph,missing]=assessMissing(this,labels,fh,ph)</a></li><li><a href="#_sub46" class="code">function [newThis,logL]=findOutliers(this,model,verbose)</a></li><li><a href="#_sub47" class="code">function Fthis=fourierTransform(this,M)</a></li><li><a href="#_sub48" class="code">function Sthis=spectrogram(this,labels,nFFT,tWin,tOverlap)</a></li><li><a href="#_sub49" class="code">function [ATS,bad]=align(this,eventTS,eventLabel,N,~)</a></li><li><a href="#_sub50" class="code">function [DTS,bad]=discretize(this,eventTS,eventLabel,N,summaryFunction)</a></li><li><a href="#_sub51" class="code">function newThis=lowPassFilter(this,fcut)</a></li><li><a href="#_sub52" class="code">function newThis=highPassFilter(this,fcut)</a></li><li><a href="#_sub53" class="code">function newThis=monotonicFilter(this,Nderiv,Nreg)</a></li><li><a href="#_sub54" class="code">function this=medianFilter(this,N)</a></li><li><a href="#_sub55" class="code">function newThis=resampleLogical(this,newTs, newT0,newN)</a></li><li><a href="#_sub56" class="code">function [ATS,bad,Data]=align_v2(this,eventTS,eventLabel,N)</a></li><li><a href="#_sub57" class="code">function eventTimes=getArrayedEvents(eventTS,eventLabel)</a></li><li><a href="#_sub58" class="code">function [alignedTS,originalDurations]=stridedTSToAlignedTS(stridedTS,N)</a></li><li><a href="#_sub59" class="code">function [figHandle,plotHandles]=plotStridedTimeSeries(stridedTS,figHandle,plotHandles)</a></li><li><a href="#_sub60" class="code">function this=join(labTSCellArray)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>  &lt; timeseries
0002     <span class="comment">%labTimeSeries  Extends timeseries (built-in MATLAB class) to meet</span>
0003     <span class="comment">%               our lab's needs for storing data. Forces timeseries to</span>
0004     <span class="comment">%               be uniformly sampled.</span>
0005     <span class="comment">%</span>
0006     <span class="comment">%labTimeSeries properties:</span>
0007     <span class="comment">%   labels - cell array of strings with labels for the columns of Data</span>
0008     <span class="comment">%   sampPeriod - time between samples, equal to 1/sampFreq</span>
0009     <span class="comment">%   sampFreq - sampling rate in Hz, equal to 1/sampPeriod</span>
0010     <span class="comment">%   Nsamples - total number of samples in timeSeries</span>
0011     <span class="comment">%   Data - matrix of data values, size is Nsamples x length(labels)</span>
0012     <span class="comment">%   Time - time values corresponding to each sample</span>
0013     <span class="comment">%   Length - should be same as Nsamples</span>
0014     <span class="comment">%</span>
0015     <span class="comment">%labTimeSeries methods:</span>
0016     <span class="comment">%   getDataAsVector - get a vector of data for a given label</span>
0017     <span class="comment">%   getDataAsTS - returns a new labTimeSeries with data for given label(s)</span>
0018     <span class="comment">%   getLabels - returns list of labels</span>
0019     <span class="comment">%   getLabelsThatMatch - returns list of labels that match a given string</span>
0020     <span class="comment">%   isaLabel - checks if a string is contained in label array</span>
0021     <span class="comment">%   getSample - samples the timeseries at arbitrary timepoints</span>
0022     <span class="comment">%   resample - resamples timeseries to a different sampling period</span>
0023     <span class="comment">%   split - returns a timeseries containing the data between to given timepoints</span>
0024     <span class="comment">%   appendData - adds more data to the timeseries (As new 'labels')</span>
0025     <span class="comment">%   addNewParameter - adds data to TS computing it from existing data</span>
0026     <span class="comment">%   getPartialDataAsVector - returns data corresponding to some labels in matrix form</span>
0027     <span class="comment">%   splitByEvents - separates the timeseries according to the events given in an event (boolean) timeseries</span>
0028     <span class="comment">%   derivate - differentiates the timeseries in time</span>
0029     <span class="comment">%   fillts - substitutes NaN values by interpolation</span>
0030     <span class="comment">%   concatenate/cat - merges two timeseries into a single one</span>
0031     <span class="comment">%   lowPassFilter - what the name says</span>
0032     <span class="comment">%   highPassFilter - what the name says</span>
0033     <span class="comment">%   monotonicFilter - calls monoLS on the data for each column</span>
0034     <span class="comment">%   medianFilter - what the name says</span>
0035     <span class="comment">%   FourierTransform - what the name says</span>
0036     <span class="comment">%   plot - plots data</span>
0037 
0038     <span class="comment">%%</span>
0039     properties(SetAccess=private)
0040         labels={<span class="string">''</span>};
0041         sampPeriod;
0042     <span class="keyword">end</span>
0043     properties(Dependent)
0044         sampFreq
0045         timeRange
0046         Nsamples
0047     <span class="keyword">end</span>
0048 
0049     <span class="comment">%%</span>
0050     methods
0051 
0052         <span class="comment">%Constructor:</span>
0053         <a name="_sub0" href="#_subfunctions" class="code">function this=labTimeSeries(data,t0,Ts,labels) </a><span class="comment">%Necessarily uniformly sampled</span>
0054             <span class="keyword">if</span> nargin==0
0055                 data=[];
0056                 time=[];
0057                 labels={};
0058                 Ts=[];
0059             <span class="keyword">else</span>
0060                 time=[0:size(data,1)-1]*Ts+t0';
0061             <span class="keyword">end</span>
0062             this=this@timeseries(data,time);
0063             this.sampPeriod=Ts;
0064             <span class="keyword">if</span> (length(labels)==size(data,2)) &amp;&amp; isa(labels,<span class="string">'cell'</span>)
0065                 this.labels=labels;
0066             <span class="keyword">else</span>
0067                 ME=MException(<span class="string">'labTimeSeries:ConstructorInconsistentArguments'</span>,<span class="string">'The size of the labels array is inconsistent with the data being provided.'</span>);
0068                 throw(ME)
0069             <span class="keyword">end</span>
0070             <span class="comment">%Check for repeat labels:</span>
0071             [~,i1,i2]=unique(lower(labels));
0072             <span class="keyword">if</span> length(i1)&lt;length(labels)
0073                 repIdx=find((sort(i1)-[1:length(i1)]')~=0,1,<span class="string">'first'</span>);
0074                 <span class="keyword">if</span> isempty(repIdx)
0075                     repIdx=length(i1)+1;
0076                 <span class="keyword">end</span>
0077                 ME=MException(<span class="string">'labTimeSeries:ConstructorRepeatedLabels'</span>,[<span class="string">'Found '</span> num2str(length(labels)-length(i1)) <span class="string">' collisions of label names. First collision is: '</span> labels{repIdx}]);
0078                     throw(ME)
0079             <span class="keyword">end</span>
0080         <span class="keyword">end</span>
0081 
0082         <span class="comment">%-------------------</span>
0083 
0084         <span class="comment">%Other I/O functions:</span>
0085         <a name="_sub1" href="#_subfunctions" class="code">function [data,time,auxLabel]=getDataAsVector(this,label)</a>
0086             <span class="keyword">if</span> nargin&lt;2 || isempty(label)
0087                 label=this.labels;
0088             <span class="keyword">end</span>
0089             <span class="keyword">if</span> isa(label,<span class="string">'char'</span>)
0090                 auxLabel={label};
0091             <span class="keyword">else</span>
0092                 auxLabel=label;
0093             <span class="keyword">end</span>
0094             time=this.Time;
0095             [boolFlag,labelIdx]=this.isaLabel(auxLabel);
0096             <span class="keyword">if</span> ~any(boolFlag)
0097                 auxLabel2=[];
0098                 <span class="keyword">for</span> i=1:length(auxLabel)
0099                     auxLabel2=[auxLabel2 this.getLabelsThatMatch(auxLabel{i})];
0100                 <span class="keyword">end</span>
0101                 [boolFlag,labelIdx]=this.isaLabel(auxLabel2);
0102                 NN=numel(auxLabel2);
0103                 warning([<span class="string">'None of the provided labels are a parameter in this timeSeries. Trying to return labels that match the provided label as a regular expression: found '</span> num2str(NN) <span class="string">' matches.'</span>])
0104                 <span class="keyword">else</span>
0105                     <span class="keyword">for</span> i=1:length(boolFlag)
0106                         <span class="keyword">if</span> ~boolFlag(i)
0107                             warning([<span class="string">'Label '</span> auxLabel{i} <span class="string">' is not a labeled dataset in this timeSeries.'</span>])
0108                         <span class="keyword">end</span>
0109                     <span class="keyword">end</span>
0110                 <span class="keyword">end</span>
0111 
0112             data=this.Data(:,labelIdx(boolFlag));
0113             <span class="keyword">if</span> nargout&gt;2
0114                 auxLabel=this.labels(labelIdx(boolFlag));
0115             <span class="keyword">end</span>
0116         <span class="keyword">end</span>
0117 
0118         <a name="_sub2" href="#_subfunctions" class="code">function [newTS,auxLabel]=getDataAsTS(this,label)</a>
0119             [data,time,auxLabel]=<a href="#_sub2" class="code" title="subfunction [data,time,auxLabel]=getDataAsVector(this,label)">getDataAsVector</a>(this,label);
0120             newTS=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(data,time(1),this.sampPeriod,auxLabel);
0121         <span class="keyword">end</span>
0122 
0123         <a name="_sub3" href="#_subfunctions" class="code">function labelList=getLabels(this)</a>
0124            labelList=this.labels;
0125         <span class="keyword">end</span>
0126         
0127         <a name="_sub4" href="#_subfunctions" class="code">function this=renameLabels(this,originalLabels,newLabels)</a>
0128             warning(<span class="string">'labTS:renameLabels:dont'</span>,<span class="string">'You should not be renaming the labels. You have been warned.'</span>)
0129             <span class="keyword">if</span> isempty(originalLabels)
0130                 originalLabels=this.labels;
0131             <span class="keyword">end</span>
0132             <span class="keyword">if</span> size(newLabels)~=size(originalLabels)
0133                 error(<span class="string">'Inconsistent label sizes'</span>)
0134             <span class="keyword">end</span>
0135             [boo,idx]=this.isaLabel(originalLabels);
0136             this.labels(idx(boo))=newLabels(boo);
0137         <span class="keyword">end</span>
0138 
0139         <a name="_sub5" href="#_subfunctions" class="code">function labelList=getLabelsThatMatch(this,exp)</a>
0140             <span class="comment">%Returns labels on this labTS that match the regular expression exp.</span>
0141             <span class="comment">%labelList=getLabelsThatMatch(this,exp)</span>
0142             <span class="comment">%INPUT:</span>
0143             <span class="comment">%this: labTS object</span>
0144             <span class="comment">%exp: any regular expression (as string).</span>
0145             <span class="comment">%OUTPUT:</span>
0146             <span class="comment">%labelList: cell array containing labels of this labTS that match</span>
0147             <span class="comment">%See also regexp</span>
0148             labelList=this.labels;
0149             flags=cellfun(@(x) ~isempty(x),regexp(labelList,exp));
0150             labelList=labelList(flags);
0151         <span class="keyword">end</span>
0152 
0153         <a name="_sub6" href="#_subfunctions" class="code">function [boolFlag,labelIdx]=isaLabel(this,label)</a>
0154             <span class="keyword">if</span> isa(label,<span class="string">'char'</span>)
0155                 auxLabel{1}=label;
0156             <span class="keyword">elseif</span> isa(label,<span class="string">'cell'</span>)
0157                 auxLabel=label;
0158             <span class="keyword">else</span>
0159                 error(<span class="string">'labTimeSeries:isaLabel'</span>,<span class="string">'label input argument has to be a string or a cell array containing strings.'</span>)
0160             <span class="keyword">end</span>
0161             auxLabel=auxLabel(:);
0162             N=length(auxLabel);
0163             M=length(this.labels);
0164             <span class="keyword">if</span> N==M &amp;&amp; all(strcmpi(auxLabel,this.labels(:))) <span class="comment">%Case in which the list is identical to the label list, save time by not calling find() recursively.</span>
0165                 <span class="comment">%If this is true, it saves about 50ms per call, or 5 secs every 100 calls</span>
0166                 <span class="comment">%If false, it adds a small overhead of less than .1ms per call, which is negligible compared to the loop that needs to be performed.</span>
0167                 boolFlag=true(N,1);
0168                 labelIdx=1:M;
0169             <span class="keyword">else</span>
0170                 [boolFlag,labelIdx] = compareListsFast(this.labels,auxLabel);
0171             <span class="keyword">end</span>
0172         <span class="keyword">end</span>
0173 
0174         <a name="_sub7" href="#_subfunctions" class="code">function data=getSample(this,timePoints,method) </a><span class="comment">%This does not seem efficient: we are creating a timeseries object (from native Matlab) and using its resample method.</span>
0175             <span class="keyword">if</span> nargin&lt;3 || isempty(method)
0176                 <span class="keyword">if</span> isa(this.Data,<span class="string">'logical'</span>)
0177                     method=<span class="string">'closest'</span>;
0178                 <span class="keyword">else</span>
0179                     method=<span class="string">'linear'</span>;
0180                 <span class="keyword">end</span>
0181             <span class="keyword">end</span>
0182 
0183             <span class="keyword">if</span> ~isempty(timePoints)
0184                 M=length(this.labels);
0185                 <span class="keyword">switch</span> method
0186                     <span class="keyword">case</span> <span class="string">'linear'</span>
0187                         data=nan(numel(timePoints),M);
0188                         notNaNIdxs=~isnan(timePoints) &amp; ~isinf(timePoints) &amp; timePoints&lt;this.Time(end) &amp; timePoints&gt;this.Time(1); <span class="comment">%Excluding NaNs, Infs and out-of-range times from interpolation.</span>
0189                         [notNaNTimes,sorting]=sort(timePoints(notNaNIdxs),<span class="string">'ascend'</span>);
0190                         newTS=<a href="#_sub11" class="code" title="subfunction newThis=resample(this,newTs,newT0,hiddenFlag)">resample</a>(this,notNaNTimes,this.Time(1),1); <span class="comment">%Using timeseres.resample which does linear interp by default</span>
0191 
0192                         newTS.Data(sorting,:)=newTS.Data;
0193                         data(notNaNIdxs,:)=newTS.Data;
0194                     <span class="keyword">case</span> <span class="string">'closest'</span>
0195                         data=nan(numel(timePoints),M);
0196                         aux=this.getIndexClosestToTimePoint(timePoints(:));
0197                         inds=~isnan(aux);
0198                         aux=aux(inds); <span class="comment">%Eliminating NaNs</span>
0199                         newData=this.Data(aux,:); <span class="comment">%This would be the new data in the simplest case.</span>
0200                         initData=newData;
0201                         <span class="comment">%But, if two samples map to the same timePoint (sub-sampling) and that timePoint corresponds</span>
0202                         <span class="comment">%to an event, just keep the closest one, to avoid repeating events.</span>
0203                         trueEventSamples=unique(aux(any(newData,2) &amp; [diff(aux);1]==0)); <span class="comment">%Unique samples that contain an event</span>
0204                         tt=this.Time(trueEventSamples);
0205                         <span class="keyword">for</span> i=1:length(trueEventSamples)
0206                             mappedInds=find(aux==trueEventSamples(i));
0207                             relevantTimePoints=timePoints(mappedInds);
0208                             Dt=abs(tt(i)-relevantTimePoints);
0209                             jj=find(Dt==min(Dt),1,<span class="string">'first'</span>); <span class="comment">%The find() is needed to resolve ties</span>
0210                             mappedInds(jj)=[];
0211                             newData(mappedInds,:)=0;
0212                         <span class="keyword">end</span>
0213                         
0214                         data(inds,:)=newData;
0215 <span class="comment">%                         %Sanity check, this can be deprecated if no errors</span>
0216 <span class="comment">%                         %found by Jan 1st 2018. [implemented Sept 11 2017]</span>
0217 <span class="comment">%                         %Check that #events did not change:</span>
0218 <span class="comment">%                         if any(sum(newData)~=sum(this.split(min(timePoints(:))-this.sampPeriod/2,max(timePoints(:))+this.sampPeriod).Data))</span>
0219 <span class="comment">%                             error('Something went wrong when resampling: number of events changed')</span>
0220 <span class="comment">%                         end</span>
0221 <span class="comment">%                         %Check that no event is present at a sample where</span>
0222 <span class="comment">%                         %it was previously not:</span>
0223 <span class="comment">%                         if any(any(newData &amp; ~initData))</span>
0224 <span class="comment">%                             error('Something went wrong when resampling: event location changed')</span>
0225 <span class="comment">%                         end</span>
0226                         <span class="comment">%TODO: add interpft1 interpolation as possible</span>
0227                         <span class="comment">%method, provided that the timepoints are equally</span>
0228                         <span class="comment">%spaced.</span>
0229                 <span class="keyword">end</span>
0230                 data=reshape(full(data),[size(timePoints),M]); <span class="comment">%Can't have sparse ND matrices (WHY??)</span>
0231             <span class="keyword">else</span>
0232                 data=[];
0233             <span class="keyword">end</span>
0234         <span class="keyword">end</span>
0235         
0236         <a name="_sub8" href="#_subfunctions" class="code">function newTS=synchTo(this,otherTS)</a>
0237            <span class="comment">%Resamples the timeseries assuring that the new time vector coincides with that of otherTS. Pads with NaN if necessary.</span>
0238            <span class="keyword">if</span> ~islogical(this.Data)
0239                 method=[];
0240            <span class="keyword">else</span>
0241                method=<span class="string">'closest'</span>;
0242            <span class="keyword">end</span>
0243            data=squeeze(this.getSample(otherTS.Time,method));
0244            newTS=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(data,otherTS.Time(1),otherTS.sampPeriod,this.labels);
0245         <span class="keyword">end</span>
0246 
0247         <a name="_sub9" href="#_subfunctions" class="code">function index=getIndexClosestToTimePoint(this,timePoints)</a>
0248             <span class="comment">%NaN returns NaN</span>
0249 
0250             <span class="comment">%aux=abs(bsxfun(@minus,this.Time(:),timePoints(:)'))&lt;=(this.sampPeriod/2+eps);</span>
0251             <span class="comment">%[ii,jj]=find(aux);</span>
0252             <span class="comment">%index=nan(size(timePoints));</span>
0253             <span class="comment">%index(jj)=ii;</span>
0254             index=round((timePoints(:)-this.Time(1))/this.sampPeriod)+1;
0255             index(index&lt;1)=1;
0256             index(index&gt;numel(this.Time))=numel(this.Time);
0257             index=reshape(index,size(timePoints));
0258             <span class="comment">%Check</span>
0259             <span class="comment">%if any(abs(this.Time(index(:))-timePoints(:))&gt;(this.sampPeriod/2-eps))</span>
0260             <span class="comment">%    error('Non consistent indexes found')</span>
0261             <span class="comment">%end</span>
0262         <span class="keyword">end</span>
0263         <span class="comment">%-------------------</span>
0264 
0265         <span class="comment">%Modifier functions:</span>
0266         <a name="_sub10" href="#_subfunctions" class="code">function newThis=resample(this,newTs,newT0,hiddenFlag)</a>
0267             this.Quality=[]; <span class="comment">%So that Quality is not resample if it exists.</span>
0268             <span class="keyword">if</span> nargin&lt;3 || isempty(newT0)
0269                 error(<span class="string">'labTS:resample'</span>,<span class="string">'Resampling using only the new sampling period as argument is no longer supported. Use resampleN if you want to interpolate keeping the exact same time range.'</span>)
0270             <span class="keyword">end</span>
0271             <span class="keyword">if</span> nargin&lt;4 || isempty(hiddenFlag) || hiddenFlag==0 <span class="comment">%hiddenFlag allows to do non-uniform sampling</span>
0272                 <span class="keyword">if</span> newTs&gt;this.sampPeriod <span class="comment">%Under-sampling! be careful of aliasing</span>
0273                     warning(<span class="string">'labTS:resample'</span>,<span class="string">'Under-sampling data, be careful of aliasing!'</span>);
0274                 <span class="keyword">end</span>
0275                 <span class="comment">%Commented on 4/4/2015 by Pablo. No longer think this is a</span>
0276                 <span class="comment">%good idea. If we are explicitly trying to do uniform</span>
0277                 <span class="comment">%resampling on the same range, should use resampleN.</span>
0278                 <span class="comment">%Otherwise, if we try to synch two signals, and there is an</span>
0279                 <span class="comment">%offset in initial time, this returns something else.</span>
0280 
0281                 newN=ceil(this.timeRange/newTs)+1;
0282                 <span class="comment">%newThis=resampleN(this,newN);</span>
0283                 newTime=newT0:newTs:this.Time(end);
0284                  <span class="keyword">if</span> ~isa(this.Data(1,1),<span class="string">'logical'</span>)
0285                         newThis=this.resample@timeseries(newTime);
0286                         newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newThis.Data,newThis.Time(1),newTs,this.labels);
0287                  <span class="keyword">else</span> <span class="comment">%logical timeseries</span>
0288                        newThis=<a href="#_sub55" class="code" title="subfunction newThis=resampleLogical(this,newTs, newT0,newN)">resampleLogical</a>(this,newTs,newT0,newN);
0289                        <span class="comment">%Can be this deprecated in favor of just using</span>
0290                        <span class="comment">%getSample() for a logical TS?</span>
0291                  <span class="keyword">end</span>
0292 
0293             <span class="keyword">elseif</span> hiddenFlag==1<span class="comment">% this allows for non-uniform resampling, and returns a timeseries object.</span>
0294                 newThis=this.resample@timeseries(newTs); <span class="comment">%Warning: Treating newTs argument as a vector containing timepoints, not a sampling period. The super-class resampling returns a super-class object.</span>
0295             <span class="keyword">else</span>
0296                 error(<span class="string">'labTS:resample'</span>,<span class="string">'HiddenFlag argument has to be 0 or 1'</span>);
0297             <span class="keyword">end</span>
0298         <span class="keyword">end</span>
0299 
0300         <a name="_sub11" href="#_subfunctions" class="code">function newThis=resampleN(this,newN,method)</a>
0301             <span class="comment">%Uniform resampling of data, over the same time range. This</span>
0302             <span class="comment">%keeps the initial time on the same value, and returns newN</span>
0303             <span class="comment">%time-samples in the time interval of the original timeseries</span>
0304             <span class="keyword">if</span> ~isempty(this.Data)
0305             <span class="keyword">if</span> nargin&lt;3 || isempty(method)
0306                  <span class="keyword">if</span> ~isa(this.Data(1,1),<span class="string">'logical'</span>)
0307                         method=<span class="string">'interpft'</span>;
0308                  <span class="keyword">else</span>
0309                      method=<span class="string">'logical'</span>;
0310                  <span class="keyword">end</span>
0311             <span class="keyword">end</span>
0312             modNewTs=this.timeRange/(newN);
0313             newTimeVec=[0:newN-1]*modNewTs+this.Time(1);
0314             <span class="keyword">switch</span> method
0315                 <span class="keyword">case</span> <span class="string">'interpft'</span>
0316                     allNaNIdxs=[];
0317                     <span class="keyword">if</span> any(isnan(this.Data(:)))
0318                         <span class="keyword">if</span> any(all(isnan(this.Data)))
0319                             allNaNIdxs=all(isnan(this.Data));
0320                             warning([<span class="string">'All data is NaNs for labels '</span> strcat(this.labels{allNaNIdxs},<span class="string">' '</span>) <span class="string">', not interpolating those: returning NaNs'</span>])
0321                         <span class="keyword">end</span>
0322                     <span class="keyword">end</span>
0323                     this.Data(:,allNaNIdxs)=0; <span class="comment">%Substituting 0's to allow the next line to run without problems</span>
0324                     <span class="keyword">if</span> any(isnan(this.Data(:))) <span class="comment">%Only if there are still NaNs after the previous step, we will substitute the missing data with linearly interpolated values</span>
0325                         warning(<span class="string">'Trying to interpolate data using Fourier Transform method (''interpft1''), but data contains NaNs (missing values) which will propagate to the full timeseries. Substituting NaNs with linearly interpolated data.'</span>)
0326                         this=<a href="#_sub36" class="code" title="subfunction this=substituteNaNs(this,method)">substituteNaNs</a>(this,<span class="string">'linear'</span>); <span class="comment">%Interpolate time-series that are not all NaN (this is, there are just some values missing)</span>
0327                     <span class="keyword">end</span>
0328                     newData=interpft1(this.Data,newN,1); <span class="comment">%Interpolation is done on a nice(r) way.</span>
0329                     newData(:,allNaNIdxs)=nan; <span class="comment">%Replacing the previously filled data with NaNs</span>
0330                 <span class="keyword">case</span> <span class="string">'logical'</span>
0331                    newThis=<a href="#_sub55" class="code" title="subfunction newThis=resampleLogical(this,newTs, newT0,newN)">resampleLogical</a>(this,modNewTs,this.Time(1),newN);
0332                    newData=newThis.Data;
0333                 <span class="keyword">otherwise</span> <span class="comment">%Method is 'linear', 'cubic' or any of the accepted methods for interp1</span>
0334                     newData=zeros(length(newTimeVec),size(this.Data,2));
0335                     <span class="keyword">for</span> i=1:size(this.Data,2)
0336                         newData(:,i)=interp1(this.Time,this.Data(:,i),newTimeVec,method,nan);
0337                     <span class="keyword">end</span>
0338             <span class="keyword">end</span>
0339             t0=this.Time(1);
0340             newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,t0,modNewTs,this.labels);
0341             <span class="keyword">else</span> <span class="comment">%this.Data==[]</span>
0342                 error(<span class="string">'labTimeSeries:resampleN'</span>,<span class="string">'Interpolating empty labTimeSeries,impossible.'</span>)
0343             <span class="keyword">end</span>
0344         <span class="keyword">end</span>
0345 
0346         <a name="_sub12" href="#_subfunctions" class="code">function newThis=split(this,t0,t1)</a>
0347 
0348             <span class="comment">%Need to test this chunk of code before enabling:</span>
0349             <span class="comment">%if isnan(t0) || isnan(t1)</span>
0350             <span class="comment">%    warning('labTS:split','One of the interval limits is NaN. Returning empty TS.')</span>
0351             <span class="comment">%    newTS=[];</span>
0352             <span class="comment">%    return</span>
0353             <span class="comment">%end</span>
0354 
0355            <span class="comment">%Check t0&gt;= Time(1)</span>
0356            <span class="comment">%Check t1&lt;= Time(end)</span>
0357            initT=this.Time(1)-eps;
0358            <span class="comment">% finalT=this.Time(end)+eps;%SL commented out, this will throw warning when trying to get the last sample</span>
0359            <span class="comment">%the original intention was good to do [t0,t1) to avoid repeated sample,</span>
0360            <span class="comment">%but the last sample (Time(end)) was never retrievable with this approach.</span>
0361            finalT = this.Time(end) + this.sampPeriod;<span class="comment">%To get the last sample without warning.</span>
0362            <span class="keyword">if</span> ~(t0&gt;= initT &amp;&amp; t1&lt;=finalT)
0363                <span class="keyword">if</span> (t1&lt;initT) || (t0&gt;=finalT)
0364                    <span class="comment">%ME=MException('labTS:split','Given time interval is not (even partially) contained within the time series.');</span>
0365                    <span class="comment">%throw(ME)</span>
0366                     warning(<span class="string">'LabTS:split'</span>,[<span class="string">'Requested interval ['</span> num2str(t0) <span class="string">','</span> num2str(t1) <span class="string">'] is fully outside the timeseries. Padding with NaNs.'</span>])
0367                <span class="keyword">else</span>
0368                    warning(<span class="string">'LabTS:split'</span>,[<span class="string">'Requested interval ['</span> num2str(t0) <span class="string">','</span> num2str(t1) <span class="string">'] is not completely contained in TimeSeries. Padding with NaNs.'</span>])
0369                <span class="keyword">end</span>
0370            <span class="keyword">end</span>
0371            <span class="comment">%Find portion of requested interval that falls within the</span>
0372            <span class="comment">%timeseries' time vector (if any).</span>
0373             i1=find(this.Time&gt;=t0,1);
0374             i2=find(this.Time&lt;t1,1,<span class="string">'last'</span>); <span class="comment">%Explicitly NOT including the final sample, so that the time series is returned as the semi-closed interval [t0, t1). This avoids repeated samples if we ask for [t0,t1) and then for [t1,t2)</span>
0375             <span class="comment">%SL: this will never be able to find the last sample</span>
0376             <span class="comment">%if set t1 = this.Time(end)+eps, this.Time(end) &lt; t1 evaluates</span>
0377             <span class="comment">%to false (eps is machine precision, too small to make the</span>
0378             <span class="comment">%boolean eval true? This may be a Matlab precision issue)</span>
0379             <span class="keyword">if</span> isempty(i1) || isempty(i2) <span class="comment">%This happens when the whole timeseries is outside the range</span>
0380         i1=1;
0381         i2=0;
0382         <span class="keyword">elseif</span> i2&lt;i1 <span class="comment">%When this happens the last included sample precedes the first included one, which happens, because of rounding, when asking for a very small interval (smaller than the sample period).</span>
0383                 warning(<span class="string">'LabTS:split'</span>,[<span class="string">'Requested interval ['</span> num2str(t0) <span class="string">','</span> num2str(t1) <span class="string">'] falls completely within two samples: returning empty timeSeries.'</span>])
0384             <span class="keyword">end</span>
0385             <span class="comment">%In case the requested time interval is larger than the</span>
0386             <span class="comment">%timeseries' actual time vector, pad with NaNs:</span>
0387             <span class="keyword">if</span> (this.Time(1)-t0)&gt;eps <span class="comment">%Case we are requesting time-samples preceding the timeseries' start-time</span>
0388                 ia=floor((this.Time(1)-t0)/this.sampPeriod); <span class="comment">%Extra samples to be added at the beginning</span>
0389             <span class="keyword">else</span>
0390                 ia=0;
0391             <span class="keyword">end</span>
0392             <span class="keyword">if</span> (t1-this.Time(end))&gt; eps <span class="comment">%Case we are requesting time-samples following the timeseries' end-time</span>
0393                 ib=floor((t1-this.Time(end))/this.sampPeriod); <span class="comment">%Extra samples to be added at the end</span>
0394             <span class="keyword">else</span>
0395                 ib=0;
0396             <span class="keyword">end</span>
0397             <span class="keyword">if</span> ~islogical(this.Data(1,1))
0398                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>([nan(ia,size(this.Data,2)) ; this.Data(i1:i2,:); nan(ib,size(this.Data,2))],this.Time(i1)-this.sampPeriod*ia,this.sampPeriod,this.labels);
0399             <span class="keyword">else</span>
0400                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>([false(ia,size(this.Data,2)) ; this.Data(i1:i2,:); false(ib,size(this.Data,2))],this.Time(i1)-this.sampPeriod*ia,this.sampPeriod,this.labels);
0401             <span class="keyword">end</span>
0402             <span class="keyword">if</span> ~isempty(this.Quality)
0403                 newThis.QualityInfo=this.QualityInfo;
0404                 k=find(strcmp(this.QualityInfo.Description,<span class="string">'missing'</span>));
0405                 newThis.Quality=[k*ones(ia,size(this.Quality,2)) ; this.Quality(i1:i2,:); k*ones(ib,size(this.Quality,2))];
0406             <span class="keyword">end</span>
0407         <span class="keyword">end</span>
0408 
0409         <a name="_sub13" href="#_subfunctions" class="code">function newThis=appendData(this,newData,newLabels) </a><span class="comment">%For back compat</span>
0410             other=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,newLabels,this.Time(1),this.sampPeriod);
0411             newThis=<a href="#_sub35" class="code" title="subfunction newThis=cat(this,other)">cat</a>(this,other);
0412         <span class="keyword">end</span>
0413 
0414         <a name="_sub14" href="#_subfunctions" class="code">function [newThis,newData]=addNewParameter(this,newParamLabel,funHandle,inputParameterLabels)</a>
0415            <span class="comment">%This function allows to compute new parameters from other existing parameters and have them added to the data.</span>
0416            <span class="comment">%This is useful when trying out new parameters without having to</span>
0417            <span class="comment">%recompute all existing parameters.</span>
0418            <span class="comment">%INPUT:</span>
0419            <span class="comment">%newPAramLAbel: string with the name of the new parameter</span>
0420            <span class="comment">%funHandle: a function handle with N input variables, whose</span>
0421            <span class="comment">%result will be used to compute the new parameter</span>
0422            <span class="comment">%inputParameterLabels: the parameters that will replace each of</span>
0423            <span class="comment">%the variables in the funHandle</span>
0424            <span class="comment">%EXAMPLE:</span>
0425            <span class="comment">%See example in parameterSeries</span>
0426 
0427            [newData]=<a href="#_sub16" class="code" title="subfunction [newData]=computeNewParameter(this,newParamLabel,funHandle,inputParameterLabels)">computeNewParameter</a>(this,newParamLabel,funHandle,inputParameterLabels);
0428            newThis=<a href="#_sub14" class="code" title="subfunction newThis=appendData(this,newData,newLabels) ">appendData</a>(this,newData,{newParamLabel}) ;
0429         <span class="keyword">end</span>
0430         
0431         <a name="_sub15" href="#_subfunctions" class="code">function [newData]=computeNewParameter(this,newParamLabel,funHandle,inputParameterLabels)</a>
0432            <span class="comment">%This function allows to compute new parameters from other existing parameters and have them added to the data.</span>
0433            <span class="comment">%This is useful when trying out new parameters without having to</span>
0434            <span class="comment">%recompute all existing parameters.</span>
0435            <span class="comment">%INPUT:</span>
0436            <span class="comment">%newPAramLAbel: string with the name of the new parameter</span>
0437            <span class="comment">%funHandle: a function handle with N input variables, whose</span>
0438            <span class="comment">%result will be used to compute the new parameter</span>
0439            <span class="comment">%inputParameterLabels: the parameters that will replace each of</span>
0440            <span class="comment">%the variables in the funHandle</span>
0441            <span class="comment">%EXAMPLE:</span>
0442            <span class="comment">%See example in parameterSeries</span>
0443            <span class="comment">%See also: addNewParameter</span>
0444            
0445            <span class="comment">%TO DO: support many new parameters together, as long as they</span>
0446            <span class="comment">%use the same funHandle, with inputParameterLabels an NxM array,</span>
0447            <span class="comment">%where N is the size of newParamLabel (# parameters to be</span>
0448            <span class="comment">%computed). Use this change in</span>
0449            <span class="comment">%linearStretch(this,labels,rangeValues) for efficiency</span>
0450            
0451            <span class="comment">%Check input sanity:</span>
0452            <span class="keyword">if</span> length(inputParameterLabels)~=nargin(funHandle)
0453                error(<span class="string">'labTS:addNewParameter'</span>,<span class="string">'Number of input arguments in function handle and number of labels in inputParameterLabels should be the same'</span>)
0454            <span class="keyword">end</span>
0455            <span class="keyword">if</span> compareListsFast(this.labels,newParamLabel)
0456                error(<span class="string">'labTS:addNewParameter'</span>,<span class="string">'Cannot add parameter because it already exists'</span>)
0457            <span class="keyword">end</span>
0458            oldData=this.getDataAsVector(inputParameterLabels);
0459            str=<span class="string">'('</span>;
0460            <span class="keyword">for</span> i=1:size(oldData,2)
0461                str=[str <span class="string">'oldData(:,'</span> num2str(i) <span class="string">'),'</span>];
0462            <span class="keyword">end</span>
0463            str(end)=<span class="string">')'</span>; <span class="comment">%Replacing last comma with parenthesis</span>
0464            eval([<span class="string">'newData=funHandle'</span> str <span class="string">';'</span>]); <span class="comment">%Isn't there a way to do this without eval?</span>
0465         <span class="keyword">end</span>
0466         
0467         <a name="_sub16" href="#_subfunctions" class="code">function newThis=removeParameter(labels)</a>
0468             [bool,idxs] = compareLists(this.labels,labels);
0469             <span class="keyword">if</span> any(~bool)
0470                 warning([{<span class="string">'Could not remove some parameters because they are not present: '</span>} labels(~bool)])
0471             <span class="keyword">end</span>
0472             newThis=this;
0473             newThis.labels(idxs(bool))=[];
0474             newThis.Data(:,idxs(bool))=[];
0475         <span class="keyword">end</span>
0476 
0477         <a name="_sub17" href="#_subfunctions" class="code">function newThis=castAsOTS(this,orientation)</a>
0478             <span class="keyword">if</span> nargin&lt;2 || isempty(orientation)
0479                 orientation=orientationInfo;
0480             <span class="keyword">end</span>
0481             newThis=orientedLabTimeSeries(this.Data,this.Time(1),this.sampPeriod,this.labels,orientation);
0482         <span class="keyword">end</span>
0483         
0484         <a name="_sub18" href="#_subfunctions" class="code">function newThis=castAsSTS(this,F,tWin,tOverlap)</a>
0485             <span class="comment">%1) Check if it satisfies STS requirements</span>
0486             dataF=this.Data;
0487             labelsF=this.labels;
0488             t0=this.Time(1);
0489             Ts=this.sampPeriod;
0490             spectroTimeSeries.inputArgsCheck(dataF,labelsF,t0,Ts,F,tWin,tOverlap)
0491             newThis=spectroTimeSeries(dataF,labelsF,t0,Ts,F,tWin,tOverlap);
0492         <span class="keyword">end</span>
0493 
0494         <a name="_sub19" href="#_subfunctions" class="code">function [data,time,auxLabel]=getPartialDataAsVector(this,label,t0,t1)</a>
0495             newThis=<a href="#_sub13" class="code" title="subfunction newThis=split(this,t0,t1)">split</a>(this.getDataAsTS(label),t0,t1);
0496             [data,time,auxLabel]=<a href="#_sub2" class="code" title="subfunction [data,time,auxLabel]=getDataAsVector(this,label)">getDataAsVector</a>(newThis,label);
0497         <span class="keyword">end</span>
0498 
0499         <a name="_sub20" href="#_subfunctions" class="code">function [steppedDataArray,bad,initTime,eventTimes]=splitByEvents(this,eventTS,eventLabel,timeMargin)</a>
0500            <span class="comment">%eventTS needs to be a labTimeSeries with binary events as data</span>
0501            <span class="comment">%If eventLabel is not given, the first data column is used as</span>
0502            <span class="comment">%the relevant event marker. If given, eventLabel must be the</span>
0503            <span class="comment">%label of one of the data columns in eventTS</span>
0504 
0505            <span class="comment">%Check needed: is eventTS a labTimeSeries?</span>
0506            <span class="keyword">if</span> nargin&gt;2
0507                 eventList=eventTS.getDataAsVector(eventLabel);
0508            <span class="keyword">else</span>
0509                eventList=eventTS.Data(:,1);
0510            <span class="keyword">end</span>
0511            <span class="comment">%Check needed: is eventList binary?</span>
0512            N=size(eventList,2); <span class="comment">%Number of events &amp; intervals to be found</span>
0513            auxList=double(eventList)*2.^[0:N-1]'; <span class="comment">%List all events in a single vector, by numbering them differently.</span>
0514            <span class="comment">%</span>
0515            <span class="keyword">if</span> nargin&lt;4 || isempty(timeMargin)
0516                timeMargin=0;
0517            <span class="keyword">end</span>
0518 
0519            <span class="comment">%TODO: this needs to call on getArrayedEvents() to avoid</span>
0520            <span class="comment">%duplicating the event-finding logic</span>
0521            
0522             refIdxLst=find(auxList==1);
0523             M=length(refIdxLst)-1;
0524             auxTime=eventTS.Time;
0525             aa=auxTime(refIdxLst);
0526             initTime=aa(1:M); <span class="comment">%Initial time of each interval identified</span>
0527             eventTimes=nan(M,N); <span class="comment">%Duration of each interval</span>
0528             eventTimes(:,1)=initTime;
0529             steppedDataArray=cell(M,N);
0530             bad=false(M,1);
0531             <span class="keyword">for</span> i=1:M <span class="comment">%Going over strides</span>
0532                 t0=auxTime(refIdxLst(i));
0533                 nextT0=auxTime(refIdxLst(i+1));
0534                 lastEventIdx=refIdxLst(i);
0535                 <span class="keyword">for</span> j=1:N-1 <span class="comment">%Going over events</span>
0536                    nextEventIdx=lastEventIdx+find(auxList(lastEventIdx+1:refIdxLst(i+1)-1)==2^mod(j,N),1,<span class="string">'first'</span>);
0537                    t1= auxTime(nextEventIdx); <span class="comment">%Look for next event</span>
0538                    <span class="keyword">if</span> ~isempty(t1) &amp;&amp; ~isempty(t0)
0539                        eventTimes(i,j+1)=t1;
0540                         steppedDataArray{i,j}=this.split(t0-timeMargin,t1+timeMargin);
0541                         t0=t1;
0542                         lastEventIdx=nextEventIdx;
0543                    <span class="keyword">else</span>
0544                        warning([<span class="string">'Events were not in order on stride '</span> num2str(i) <span class="string">', returning empty labTimeSeries.'</span>])
0545                         <span class="keyword">if</span> islogical(this.Data)
0546                             steppedDataArray{i,j}=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(false(0,size(this.Data,2)),0,1,this.labels);
0547                         <span class="keyword">else</span>
0548                             steppedDataArray{i,j}=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(zeros(0,size(this.Data,2)),0,1,this.labels); <span class="comment">%Empty labTimeSeries</span>
0549                         <span class="keyword">end</span>
0550                         bad(i)=true;
0551                    <span class="keyword">end</span>
0552 
0553                 <span class="keyword">end</span>
0554                 steppedDataArray{i,N}=this.split(t0-timeMargin,nextT0+timeMargin); <span class="comment">%This line is executed for the last interval btw events, which is the only one when there is a single event separating (N=1).</span>
0555             <span class="keyword">end</span>
0556         <span class="keyword">end</span>
0557 
0558         <a name="_sub21" href="#_subfunctions" class="code">function [slicedTS,initTime,duration]=sliceTS(this,timeBreakpoints,timeMargin)</a>
0559           <span class="comment">%Slices a single timeseries into a cell array of smaller timeseries, breaking at the given timeBreakpoints</span>
0560           slicedTS=cell(1,length(timeBreakpoints)-1);
0561           <span class="keyword">for</span> i=1:length(timeBreakpoints)-1
0562               <span class="keyword">if</span> isnan(timeBreakpoints(i)) || isnan(timeBreakpoints(i+1)) || timeBreakpoints(i+1)&lt;timeBreakpoints(i)
0563                   warning(<span class="string">'off'</span>) <span class="comment">%Preventing overload of annoying warnings</span>
0564               <span class="keyword">end</span>
0565               slicedTS{i}=this.split(timeBreakpoints(i)-timeMargin,timeBreakpoints(i+1)+timeMargin);
0566               warning(<span class="string">'on'</span>)
0567           <span class="keyword">end</span>
0568             initTime=timeBreakpoints(1:end-1)-timeMargin;
0569             duration=diff(timeBreakpoints)+2*timeMargin;
0570         <span class="keyword">end</span>
0571 
0572         <a name="_sub22" href="#_subfunctions" class="code">function this=times(this,constant)</a>
0573             this.Data=this.Data .* constant;
0574             <span class="keyword">if</span> numel(constant)==1
0575                 s=num2str(constant);
0576             <span class="keyword">else</span>
0577                 s=<span class="string">'k'</span>; <span class="comment">%Generic constant string</span>
0578             <span class="keyword">end</span>
0579             this.labels=strcat([s <span class="string">'*'</span>],this.labels);
0580         <span class="keyword">end</span>
0581         
0582         <a name="_sub23" href="#_subfunctions" class="code">function this=rectify(this)</a>
0583             this.Data=abs(this.Data);
0584             this.labels=strcat(strcat(this.labels),<span class="string">'abs'</span>);
0585         <span class="keyword">end</span>
0586 
0587         <a name="_sub24" href="#_subfunctions" class="code">function newThis=plus(this,other)</a>
0588             M=size(this.Data,2);
0589             <span class="keyword">if</span> size(other.Data,2)~=M
0590                 error(<span class="string">'Inconsistent sizes for sum'</span>)
0591             <span class="keyword">end</span>
0592             newLabels=cell(size(this.labels));
0593             <span class="keyword">for</span> i=1:M
0594                 newLabels{i}=[<span class="string">'('</span> this.labels{i} <span class="string">' + '</span> other.labels{i} <span class="string">')'</span>];
0595             <span class="keyword">end</span>
0596             <span class="keyword">if</span> abs(this.Time(1)-other.Time(1))&lt;eps &amp;&amp; abs(this.sampPeriod-other.sampPeriod)&lt;eps &amp;&amp; length(this.labels)==length(other.labels)
0597                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(this.Data+other.Data,this.Time(1),this.sampPeriod,newLabels);
0598             <span class="keyword">else</span>
0599                 error(<span class="string">''</span>)
0600             <span class="keyword">end</span>
0601         <span class="keyword">end</span>
0602 
0603         <a name="_sub25" href="#_subfunctions" class="code">function newThis=minus(this,other)</a>
0604             <span class="comment">%Subtracts two labTSs</span>
0605             <span class="comment">%Could be deprecated in favor of: newThis=this + -1*other;</span>
0606             M=size(this.Data,2);
0607             <span class="keyword">for</span> i=1:M
0608                 newLabels{i}=[<span class="string">'('</span> this.labels{i} <span class="string">' - '</span> other.labels{i} <span class="string">')'</span>];
0609             <span class="keyword">end</span>
0610             <span class="keyword">if</span> abs(this.Time(1)-other.Time(1))&lt;eps &amp;&amp; abs(this.sampPeriod-other.sampPeriod)&lt;eps &amp;&amp; length(this.labels)==length(other.labels)
0611                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(this.Data-other.Data,this.Time(1),this.sampPeriod,newLabels);
0612             <span class="keyword">end</span>
0613         <span class="keyword">end</span>
0614 
0615         <a name="_sub26" href="#_subfunctions" class="code">function newThis=derivate(this)</a>
0616             <span class="comment">%This is kept for legacy compatibility purposes only</span>
0617             partialThis=this.derivative;
0618             pad=nan(1,size(this.Data,2));
0619             newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>([pad;partialThis.Data;pad],this.Time(1),this.sampPeriod,partialThis.labels);
0620         <span class="keyword">end</span>
0621         
0622         <a name="_sub27" href="#_subfunctions" class="code">function [newThis,lag]=derivative(this,diffOrder)</a>
0623             <span class="comment">%Numerical differentiation of labTS</span>
0624             <span class="comment">%diffOrder establishes the order of the filter used for</span>
0625             <span class="comment">%estimation, NOT higher order derivatives [we are approximating</span>
0626             <span class="comment">%an IIR filter -the true derivative- through a FIR].</span>
0627             <span class="comment">%Ref: https://en.wikipedia.org/wiki/Finite_difference_coefficient</span>
0628             <span class="keyword">if</span> nargin&lt;2 || isempty(diffOrder)
0629                 diffOrder=2; <span class="comment">%Default</span>
0630             <span class="keyword">end</span>
0631             lag=diffOrder/2;
0632             <span class="keyword">switch</span> diffOrder
0633                <span class="keyword">case</span> 1
0634                    w= [1 -1];
0635                <span class="keyword">case</span> 2
0636                    w=.5*[1 0 -1];
0637                <span class="keyword">case</span> 4
0638                    w=[-1 8 0 -8 1]/12;
0639                <span class="keyword">case</span> 6
0640                    w=[1 -9 45 0 -45 9 -1]/60;
0641                <span class="keyword">case</span> 8
0642                    w=[-1/56 4/21 -1 4 0 -4 1 -4/21 1/56]/5;
0643                <span class="keyword">otherwise</span>
0644                    error(<span class="string">'Order not supported'</span>)
0645             <span class="keyword">end</span>
0646 
0647             M=size(this.Data,2);
0648             newData=conv2(this.Data,w',<span class="string">'valid'</span>)/this.sampPeriod;
0649             <span class="comment">%newData=[nan(order,M);.5*(this.Data(3:end,:)-this.Data(1:end-2,:));nan(order,M)]/this.sampPeriod; %Centered differential</span>
0650             <span class="keyword">if</span> mod(diffOrder,2)==0 <span class="comment">%For even order differences, we can preserve the sampling of the time series, padding with NaN on the edges</span>
0651                 newT0=this.Time(1);
0652                 newData=<a href="#_sub35" class="code" title="subfunction newThis=cat(this,other)">cat</a>(1,nan(lag,size(newData,2)),newData,nan(lag,size(newData,2)));
0653             <span class="keyword">else</span>
0654                 newT0=this.Time(1)+lag*this.sampPeriod;
0655             <span class="keyword">end</span>
0656             newLabels=strcat(<span class="string">'d/dt'</span>,{<span class="string">' '</span>},this.labels);
0657             newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,newT0,this.sampPeriod,newLabels);
0658         <span class="keyword">end</span>
0659         
0660         <a name="_sub28" href="#_subfunctions" class="code">function newThis=integrate(this,initValues)</a>
0661             <span class="comment">%This is the inverse operator of derivative when used with</span>
0662             <span class="comment">%diffOrder=1;</span>
0663             M=size(this.Data,2);
0664             <span class="keyword">if</span> nargin&lt;2 || isempty(initValues)
0665                initValues=zeros(1,M);  <span class="comment">%Default initial condition = 0</span>
0666                <span class="comment">%Initial values represent the integrated data values HALF A</span>
0667                <span class="comment">%SAMPLE before the first sample of this.</span>
0668                <span class="comment">%</span>
0669             <span class="keyword">end</span>
0670             <span class="keyword">if</span> numel(initValues)~=M
0671                 error(<span class="string">'Initial values mismatch between Data and initValues'</span>)
0672             <span class="keyword">end</span>
0673             newData=bsxfun(@<a href="#_sub25" class="code" title="subfunction newThis=plus(this,other)">plus</a>,initValues(:)',cumsum([zeros(1,M); this.Data],1) * this.sampPeriod); 
0674             lag=-.5;
0675             newLabels=strcat(<span class="string">'\int'</span>,{<span class="string">' '</span>},this.labels,{<span class="string">' '</span>},<span class="string">'dt'</span>);
0676             newT0=this.Time(1)+lag*this.sampPeriod;
0677             newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,newT0,this.sampPeriod,newLabels);
0678         <span class="keyword">end</span>
0679 
0680         <a name="_sub29" href="#_subfunctions" class="code">function newthis=equalizeEnergyPerChannel(this)</a>
0681             <span class="comment">%Equalizes each channel such that the second moment of each</span>
0682             <span class="comment">%channel equals 1, E(x^2)=1</span>
0683             newthis=this;
0684             newthis.Data=bsxfun(@rdivide,this.Data,sqrt(nanmean(this.Data.^2,1)));
0685         <span class="keyword">end</span>
0686 
0687         <a name="_sub30" href="#_subfunctions" class="code">function newthis=equalizeVarPerChannel(this)</a>
0688             <span class="comment">%Equalizes each channel such that the second moment  about the mean of each</span>
0689             <span class="comment">%channel equals 1, E((x-E(x))^2)=1</span>
0690             newthis=this;
0691             newthis.Data=bsxfun(@rdivide,this.Data,sqrt(nanvar(this.Data,[],1)));
0692         <span class="keyword">end</span>
0693 
0694         <a name="_sub31" href="#_subfunctions" class="code">function newthis=demean(this)</a>
0695             newthis=this;
0696             newthis.Data=bsxfun(@<a href="#_sub26" class="code" title="subfunction newThis=minus(this,other)">minus</a>,this.Data,nanmean(this.Data));
0697         <span class="keyword">end</span>
0698 
0699         <a name="_sub32" href="#_subfunctions" class="code">function this=fillts(this) </a><span class="comment">%TODO: Deprecate</span>
0700             warning(<span class="string">'labTS.fillts is being deprecated. Use substituteNaNs instead.'</span>)
0701             this=<a href="#_sub36" class="code" title="subfunction this=substituteNaNs(this,method)">substituteNaNs</a>(this,<span class="string">'linear'</span>);
0702         <span class="keyword">end</span>
0703 
0704         <a name="_sub33" href="#_subfunctions" class="code">function newThis=concatenate(this,other)</a>
0705             <span class="comment">%Check if time vectors are the same</span>
0706             <span class="keyword">if</span> all(this.Time==other.Time)
0707                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>([this.Data,other.Data],this.Time(1),this.sampPeriod,[this.labels(:)', other.labels(:)']);
0708             <span class="keyword">else</span>
0709                 error(<span class="string">'labTimeSeries:concatenate'</span>,<span class="string">'Cannot concatenate timeseries with different Time vectors.'</span>)
0710             <span class="keyword">end</span>
0711         <span class="keyword">end</span>
0712         <a name="_sub34" href="#_subfunctions" class="code">function newThis=cat(this,other)</a>
0713             newThis=<a href="#_sub34" class="code" title="subfunction newThis=concatenate(this,other)">concatenate</a>(this,other);
0714         <span class="keyword">end</span>
0715 
0716         <a name="_sub35" href="#_subfunctions" class="code">function this=substituteNaNs(this,method)</a>
0717             <span class="keyword">if</span> nargin&lt;2 || isempty(method)
0718                 method=<span class="string">'linear'</span>;
0719             <span class="keyword">end</span>
0720             badColumns=sum(~isnan(this.Data))&lt;2;
0721             <span class="keyword">if</span> any(badColumns) <span class="comment">%Returns true if any TS contained in the data is all NaN</span>
0722                 <span class="comment">%FIXME: This throws an exception now, but it should just</span>
0723                 <span class="comment">%return all NaN labels as all NaN and substitute missing</span>
0724                 <span class="comment">%values in the others.</span>
0725                 warning(<span class="string">'labTimeSeries:substituteNaNs'</span>,<span class="string">'timeseries contains at least one label that is all (or all but one sample) NaN. Can''t replace those values (no data to use as reference), setting to 0.'</span>)
0726                 this.Data(:,badColumns)=0;
0727             <span class="keyword">end</span>
0728             <span class="comment">%this.Quality=zeros(size(this.Data),'int8');</span>
0729             aux=isnan(this.Data);
0730              <span class="keyword">for</span> i=1:size(this.Data,2) <span class="comment">%Going through labels</span>
0731                  auxIdx=aux(:,i);
0732                  this.Data(auxIdx,i)=interp1(this.Time(~auxIdx),this.Data(~auxIdx,i),this.Time(auxIdx),method,0); <span class="comment">%Extrapolation values are filled with 0,</span>
0733              <span class="keyword">end</span>
0734              <span class="comment">%Saving quality data (to mark which samples were interpolated):</span>
0735              this.Quality=int8(aux); <span class="comment">%Matlab's timeseries stores this as int8. I would have preferred a sparse array.</span>
0736              this.QualityInfo.Code=[0 1];
0737              this.QualityInfo.Description={<span class="string">'good'</span>,<span class="string">'missing'</span>};
0738         <span class="keyword">end</span>
0739 
0740         <a name="_sub36" href="#_subfunctions" class="code">function newThis=thresholdByChannel(this,th,label,moreThanFlag)</a>
0741             newThis=this;
0742             <span class="keyword">if</span> nargin&lt;4 || isempty(moreThanFlag) || moreThanFlag==0
0743                 newThis.Data(newThis.getDataAsVector(label)&lt;th,:)=0;
0744             <span class="keyword">elseif</span> moreThanFlag==1
0745                 newThis.Data(newThis.getDataAsVector(label)&gt;th,:)=0;
0746             <span class="keyword">end</span>
0747         <span class="keyword">end</span>
0748 
0749         <span class="comment">%------------------</span>
0750 
0751         <span class="comment">%Getters for dependent properties</span>
0752         <a name="_sub37" href="#_subfunctions" class="code">function fs=get.sampFreq(this)</a>
0753             fs=1/this.sampPeriod;
0754         <span class="keyword">end</span>
0755 
0756         <a name="_sub38" href="#_subfunctions" class="code">function tr=get.timeRange(this)</a>
0757             tr=(this.Nsamples)*this.sampPeriod;
0758         <span class="keyword">end</span>
0759 
0760         <a name="_sub39" href="#_subfunctions" class="code">function Nsamp=get.Nsamples(this)</a>
0761             Nsamp=this.TimeInfo.Length;
0762         <span class="keyword">end</span>
0763 
0764         <span class="comment">%Display</span>
0765         <a name="_sub40" href="#_subfunctions" class="code">function [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) </a><span class="comment">%Alternative plot: all the traces go in different axes</span>
0766             <span class="keyword">if</span> nargin&lt;2 || isempty(h)
0767                 h=figure;
0768             <span class="keyword">else</span>
0769                 figure(h)
0770             <span class="keyword">end</span>
0771             N=length(this.labels);
0772             <span class="keyword">if</span> nargin&lt;3 || isempty(labels)
0773                 relData=this.Data;
0774                 relLabels=this.labels;
0775                 <span class="keyword">if</span> ~isempty(this.Quality)
0776                     relQual=this.Quality==1;
0777                 <span class="keyword">else</span>
0778                     relQual=true(size(relData));
0779                 <span class="keyword">end</span>
0780             <span class="keyword">else</span>
0781                [relData,~,relLabels]=this.getDataAsVector(labels);
0782                N=size(relData,2);
0783             <span class="keyword">end</span>
0784             <span class="keyword">if</span> nargin&lt;4 || isempty(plotHandles) || length(plotHandles)&lt;length(relLabels)
0785                 [b,a]=getFigStruct(length(relLabels));
0786                 plotHandles=tight_subplot(b,a,[.05 .05],[.05 .05], [.05 .05]); <span class="comment">%External function</span>
0787             <span class="keyword">end</span>
0788             <span class="keyword">if</span> nargin&lt;7 || isempty(lineWidth)
0789                 lineWidth=2;
0790             <span class="keyword">end</span>
0791             ax2=[];
0792             h1=[];
0793             <span class="keyword">if</span> any(~isreal(relData(:)))
0794                 warning(<span class="string">'labTimeSeries:plot'</span>,<span class="string">'Data is complex, plotting the modulus only.'</span>)
0795                 relData=abs(relData);
0796             <span class="keyword">end</span>
0797             <span class="keyword">for</span> i=1:N
0798                 h1(i)=plotHandles(i);
0799                 subplot(h1(i))
0800                 hold on
0801                 <span class="keyword">if</span> nargin&lt;6 || isempty(color)
0802                     pp=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(this.Time,relData(:,i),<span class="string">'LineWidth'</span>,lineWidth);
0803                 <span class="keyword">else</span>
0804                     pp=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(this.Time,relData(:,i),<span class="string">'LineWidth'</span>,lineWidth,<span class="string">'Color'</span>,color);
0805                 <span class="keyword">end</span>
0806                 <span class="comment">%plot(this.Time(relQual(:,i)),relData(relQual(:,i),i),'rx')</span>
0807                 uistack(pp,<span class="string">'top'</span>)
0808                 ylabel(relLabels{i})
0809                 <span class="comment">%if i==ceil(N/2)</span>
0810                 <span class="comment">%    xlabel('Time (s)')</span>
0811                 <span class="comment">%end</span>
0812                 hold off
0813                 <span class="keyword">if</span> nargin&gt;4 &amp;&amp; ~isempty(events)
0814                     lls={<span class="string">'LHS'</span>,<span class="string">'RTO'</span>,<span class="string">'RHS'</span>,<span class="string">'LTO'</span>};
0815                     [ii,jj]=find(events.getDataAsTS(lls).Data);
0816                     [ii,iaux]=sort(ii);
0817                     jj=jj(iaux);
0818                     ax1=gca;
0819                     <span class="comment">%ax2(i) = axes('Position',ax1.Position,...</span>
0820                     <span class="comment">%'XAxisLocation','top',...</span>
0821                     <span class="comment">%'YAxisLocation','right',...</span>
0822                     <span class="comment">%'Color','none');%,'XColor','r','YColor','r');</span>
0823                     <span class="comment">%[tt,i2]=unique(events.Time(ii));</span>
0824                    set(ax1,<span class="string">'XTick'</span>,events.Time(ii),<span class="string">'XTickLabel'</span>,lls(jj))
0825                    grid on
0826                 <span class="keyword">end</span>
0827             <span class="keyword">end</span>
0828             <span class="comment">%linkaxes([h1,ax2],'x')</span>
0829             plotHandles=h1;
0830         <span class="keyword">end</span>
0831         
0832         <a name="_sub41" href="#_subfunctions" class="code">function [h,plotHandles]=plotAligned(this,h,labels,plotHandles,events,color,lineWidth)</a>
0833             error(<span class="string">'Unimplemented'</span>)
0834             <span class="comment">%First attempt: align the data to the first column of events</span>
0835             <span class="comment">%provided</span>
0836             <span class="keyword">for</span> i=1:length(ee)
0837                this.split(t1,t2).plot
0838             <span class="keyword">end</span>
0839         <span class="keyword">end</span>
0840 
0841         <a name="_sub42" href="#_subfunctions" class="code">function [h,plotHandles]=bilateralPlot(this,h,labels,plotHandles,events,color,lineWidth)</a>
0842             <span class="comment">%Ideally we would plot 'L' and 'R' timeseries on top of each</span>
0843             <span class="comment">%other, to do a bilateral comparison. Need to implement.</span>
0844             <span class="keyword">if</span> nargin&lt;2 || isempty(h)
0845                 h=figure;
0846             <span class="keyword">else</span>
0847                 figure(h)
0848             <span class="keyword">end</span>
0849             <span class="keyword">if</span> nargin&lt;5 || isempty(events)
0850                 events=[];
0851             <span class="keyword">end</span>
0852             <span class="keyword">if</span> nargin&lt;6 || isempty(color)
0853                 color=[];
0854             <span class="keyword">end</span>
0855             <span class="keyword">if</span> nargin&lt;3 || isempty(labels)
0856                 labels=this.labels;
0857             <span class="keyword">end</span>
0858             suffix=unique(cellfun(@(x) x(2:end),labels,<span class="string">'UniformOutput'</span>,false));
0859             <span class="keyword">if</span> nargin&lt;4 || isempty(plotHandles) || length(plotHandles)&lt;length(suffix)
0860                 [b,a]=getFigStruct(length(suffix));
0861                 plotHandles=tight_subplot(b,a,[.05 .05],[.05 .05], [.05 .05]); <span class="comment">%External function</span>
0862             <span class="keyword">end</span>
0863             <span class="keyword">if</span> nargin&lt;7 || isempty(lineWidth)
0864                 lineWidth=2;
0865             <span class="keyword">end</span>
0866             [h,plotHandles]=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(this,h,strcat(<span class="string">'L'</span>,suffix),plotHandles,events,color,lineWidth);
0867             [h,plotHandles]=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(this,h,strcat(<span class="string">'R'</span>,suffix),plotHandles,events,color,lineWidth);
0868             <span class="keyword">for</span> i=1:length(suffix)
0869                 subplot(plotHandles(i))
0870                 ylabel(suffix{i})
0871                 <span class="keyword">if</span> i==length(suffix)
0872                 legend(<span class="string">'L'</span>,<span class="string">'R'</span>)
0873                 <span class="keyword">end</span>
0874             <span class="keyword">end</span>
0875         <span class="keyword">end</span>
0876 
0877         <a name="_sub43" href="#_subfunctions" class="code">function h=dispCov(this)</a>
0878            h=figure;
0879            dd=cov(this.Data);
0880            imagesc(dd)
0881            set(gca,<span class="string">'XTick'</span>,1:length(this.labels),<span class="string">'XTickLabels'</span>,this.labels,<span class="string">'XTickLabelRotation'</span>,90,<span class="string">'YTick'</span>,1:length(this.labels),<span class="string">'YTickLabels'</span>,this.labels,<span class="string">'YTickLabelRotation'</span>,0)
0882            colorbar
0883            caxis([-1 1]*max(dd(:)));
0884         <span class="keyword">end</span>
0885         
0886         <a name="_sub44" href="#_subfunctions" class="code">function [fh,ph,missing]=assessMissing(this,labels,fh,ph)</a>
0887             noDisp=false;
0888             <span class="keyword">if</span> nargin&lt;3 || isempty(fh)
0889                 fh=figure();
0890             <span class="keyword">elseif</span> fh==-1
0891                 noDisp=true;
0892             <span class="keyword">else</span>
0893                 figure(fh)
0894                 <span class="keyword">if</span> nargin&lt;4
0895                     ph=gca;
0896                 <span class="keyword">else</span>
0897                     axes(ph)
0898             <span class="keyword">end</span>
0899             <span class="keyword">end</span>
0900             
0901             <span class="keyword">if</span> nargin&lt;2
0902                 labels=this.labels;
0903             <span class="keyword">end</span>
0904             data=this.getDataAsVector(labels);
0905             missing=isnan(data);
0906             miss=missing(:,any(missing));
0907             
0908             <span class="keyword">if</span> ~noDisp
0909             pp=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(miss,<span class="string">'o'</span>);
0910             aux=labels(any(missing));
0911             <span class="keyword">for</span> i=1:length(pp)
0912                 set(pp(i),<span class="string">'DisplayName'</span>,[aux{i} <span class="string">' ('</span> num2str(sum(miss(:,i))) <span class="string">' frames)'</span>])
0913             <span class="keyword">end</span>
0914             legend(pp)
0915             title(<span class="string">'Missing markers'</span>)
0916             xlabel(<span class="string">'Time (frames)'</span>)
0917             set(gca,<span class="string">'YTick'</span>,[0 1],<span class="string">'YTickLabel'</span>,{<span class="string">'Present'</span>,<span class="string">'Missing'</span>})
0918             <span class="keyword">else</span>
0919                 fprintf([<span class="string">'Missing data in '</span> num2str(sum(any(missing,2))) <span class="string">'/'</span> num2str(size(missing,1)) <span class="string">' frames, avg. '</span> num2str(sum(missing(:))/sum(any(missing,2)),3) <span class="string">' per frame.\n'</span>]);
0920           <span class="keyword">end</span>
0921         <span class="keyword">end</span>
0922         
0923         <a name="_sub45" href="#_subfunctions" class="code">function [newThis,logL]=findOutliers(this,model,verbose)</a>
0924             <span class="comment">%Uses marker model data to assess outliers</span>
0925                 
0926                 d=this.getDataAsVector(model.markerLabels)';
0927                 l=this.labels;
0928                 [out,logL]=model.outlierDetect(d,-4);
0929                 [boolF,idx]=this.isaLabel(model.markerLabels);
0930                 aux(:,idx(boolF))=(out==1)';
0931                 this.Quality=aux;
0932             
0933             <span class="keyword">if</span> verbose
0934                 fprintf([<span class="string">'Outlier data in '</span> num2str(sum(any(out,1))) <span class="string">'/'</span> num2str(size(out,2)) <span class="string">' frames, avg. '</span> num2str(sum(out(:))/sum(any(out,1))) <span class="string">' per frame.\n'</span>]);
0935                 <span class="keyword">for</span> j=1:size(out,1)
0936                     <span class="keyword">if</span> sum(out(j,:)==1)&gt;0
0937                     disp([l{j} <span class="string">': '</span> num2str(sum(out(j,:)==1)) <span class="string">' frames'</span>])
0938                     <span class="keyword">end</span>
0939                 <span class="keyword">end</span>
0940             <span class="keyword">end</span>
0941 <span class="comment">%             s=naiveDistances.summaryStats(d);</span>
0942 <span class="comment">%             s=s(model.activeStats,:)';</span>
0943 <span class="comment">%             m=model.statMedian;</span>
0944 <span class="comment">%             m=m(model.activeStats);</span>
0945 <span class="comment">%             ss=model.getRobustStd(.94);</span>
0946 <span class="comment">%             ss=3*ss(model.activeStats); %3 standard devs</span>
0947 <span class="comment">%             aux=model.loglikelihood(d)&lt;-4^2/2;</span>
0948 <span class="comment">%             figure; pp=plot(s); axis tight; hold on;</span>
0949 <span class="comment">%             for j=1:size(s,2)</span>
0950 <span class="comment">%                 patch([1 size(s,1) size(s,1) 1],[m(j)-ss(j) m(j)-ss(j) m(j)+ss(j) m(j)+ss(j)],pp(j).Color,'FaceAlpha',.3,'EdgeColor','None')</span>
0951 <span class="comment">%                 plot(find(aux(j,:)),s(aux(j,:),j),'x','Color',pp(j).Color,'MarkerSize',4);</span>
0952 <span class="comment">%             end</span>
0953             newThis=this;
0954         <span class="keyword">end</span>
0955 
0956         <span class="comment">%Other</span>
0957         <a name="_sub46" href="#_subfunctions" class="code">function Fthis=fourierTransform(this,M) </a><span class="comment">%Changed on Apr 1st 2015, to return a timeseries. Now ignores second argument</span>
0958             <span class="keyword">if</span> nargin&gt;1
0959                 warning(<span class="string">'labTimeSeries:fourierTransform'</span>,<span class="string">'Ignoring second argument'</span>)
0960             <span class="keyword">end</span>
0961             [F,f] = DiscreteTimeFourierTransform(this.Data,this.sampFreq);
0962             Fthis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(F,f(1),f(2)-f(1),strcat(strcat(<span class="string">'F('</span>,this.labels),<span class="string">')'</span>));
0963             Fthis.TimeInfo.Units=<span class="string">'Hz'</span>;
0964         <span class="keyword">end</span>
0965 
0966         <a name="_sub47" href="#_subfunctions" class="code">function Sthis=spectrogram(this,labels,nFFT,tWin,tOverlap)</a>
0967             <span class="keyword">if</span> nargin&lt;2
0968                 labels=[];
0969             <span class="keyword">end</span>
0970             <span class="keyword">if</span> nargin&lt;3
0971                 nFFT=[];
0972             <span class="keyword">end</span>
0973             <span class="keyword">if</span> nargin&lt;4
0974                 tWin=[];
0975             <span class="keyword">end</span>
0976             <span class="keyword">if</span> nargin&lt;5
0977                 tOverlap=[];
0978             <span class="keyword">end</span>
0979             Sthis = spectroTimeSeries.getSTSfromTS(this,labels,nFFT,tWin,tOverlap);
0980         <span class="keyword">end</span>
0981 
0982         <a name="_sub48" href="#_subfunctions" class="code">function [ATS,bad]=align(this,eventTS,eventLabel,N,~)</a>
0983             <span class="keyword">if</span> nargin&lt;3 || isempty(eventLabel)
0984                 eventLabel=eventTS.labels(1);
0985             <span class="keyword">end</span>    
0986             <span class="keyword">if</span> nargin&lt;4 || isempty(N)
0987                 N=256*ones(size(eventLabel));
0988             <span class="keyword">end</span>
0989             [ATS,bad]=this.align_v2(eventTS.split(this.Time(1)-this.sampPeriod,this.Time(end)+this.sampPeriod),eventLabel,N);
0990         <span class="keyword">end</span>
0991         
0992         <a name="_sub49" href="#_subfunctions" class="code">function [DTS,bad]=discretize(this,eventTS,eventLabel,N,summaryFunction)</a>
0993             <span class="comment">%Discretizes a time-series by averaging data across different</span>
0994             <span class="comment">%phases of gait. The phases are defined by intervals between</span>
0995             <span class="comment">%given events, and in turn these can be divided into sub-phases</span>
0996             <span class="keyword">if</span> nargin&lt;3 || isempty(eventLabel)
0997                 eventLabel=eventTS.labels(1);
0998             <span class="keyword">end</span>
0999             <span class="comment">%NEw attempt, no alignment:</span>
1000             eventTimes=labTimeSeries.getArrayedEvents(eventTS,eventLabel);
1001             bad=any(isnan(eventTimes(1:end-1,:)),2);
1002             expEventTimes=alignedTimeSeries.expandEventTimes(eventTimes',N);
1003             ee=[expEventTimes(:); eventTimes(<span class="keyword">end</span>,1)];
1004             [slicedTS]=this.sliceTS(ee,0);
1005             <span class="keyword">if</span> nargin&lt;5 || isempty(summaryFunction)
1006                 summaryFunction=<span class="string">'nanmean'</span>;<span class="comment">%nanmean, only along the columns, so that if we have NAN data, and to account for the odd instance when we only have one row or data in our slicedTS</span>
1007             <span class="keyword">end</span>
1008             eval([<span class="string">'myfun=@(x) '</span> summaryFunction <span class="string">'(x,1);'</span>]);
1009             d=cell2mat(cellfun(@(x) myfun(x.Data),slicedTS,<span class="string">'UniformOutput'</span>,false)'); 
1010             [M,N1]=size(expEventTimes);        M2=size(d,2);
1011             d=permute(reshape(d,sum(N),N1,M2),[1,3,2]);
1012             DTS=alignedTimeSeries(0,1,d,this.labels,N,eventLabel,eventTimes');
1013         <span class="keyword">end</span>
1014 
1015         <a name="_sub50" href="#_subfunctions" class="code">function newThis=lowPassFilter(this,fcut)</a>
1016                 Wn=fcut*2/this.sampFreq;
1017                 Wst=min([2*Wn,Wn+.2*(1-Wn)]);
1018                filterList{1}=fdesign.lowpass(<span class="string">'Fp,Fst,Ap,Ast'</span>,Wn,Wst,3,10); <span class="comment">%</span>
1019                 <a href="#_sub51" class="code" title="subfunction newThis=lowPassFilter(this,fcut)">lowPassFilter</a>=design(filterList{1},<span class="string">'butter'</span>);
1020                 newData=filtfilthd_short(<a href="#_sub51" class="code" title="subfunction newThis=lowPassFilter(this,fcut)">lowPassFilter</a>,this.Data,<span class="string">'reflect'</span>,this.sampFreq);  <span class="comment">%Ext function</span>
1021                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,this.Time(1),this.sampPeriod,this.labels);
1022                 <span class="keyword">if</span> ~isfield(this.UserData,<span class="string">'processingInfo'</span>)
1023                     this.UserData.processingInfo={};
1024                 <span class="keyword">end</span>
1025                 newThis.UserData=this.UserData;
1026                 newThis.UserData.processingInfo{end+1}=filterList{1};
1027         <span class="keyword">end</span>
1028         
1029         <a name="_sub51" href="#_subfunctions" class="code">function newThis=highPassFilter(this,fcut)</a>
1030                 Wn=fcut*2/this.sampFreq;
1031                 filterList{1}=fdesign.highpass(<span class="string">'Fst,Fp,Ast,Ap'</span>,Wn/2,Wn,10,3);
1032                 <a href="#_sub52" class="code" title="subfunction newThis=highPassFilter(this,fcut)">highPassFilter</a>=design(filterList{1},<span class="string">'butter'</span>);
1033                 newData=filtfilthd_short(<a href="#_sub52" class="code" title="subfunction newThis=highPassFilter(this,fcut)">highPassFilter</a>,this.Data,<span class="string">'reflect'</span>,this.sampFreq);
1034                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,this.Time(1),this.sampPeriod,this.labels);
1035                 <span class="keyword">if</span> ~isfield(this.UserData,<span class="string">'processingInfo'</span>)
1036                     this.UserData.processingInfo={};
1037                 <span class="keyword">end</span>
1038                 newThis.UserData=this.UserData;
1039                 newThis.UserData.processingInfo{end+1}=filterList{1};
1040         <span class="keyword">end</span>
1041 
1042         <a name="_sub52" href="#_subfunctions" class="code">function newThis=monotonicFilter(this,Nderiv,Nreg)</a>
1043             <span class="keyword">if</span> nargin&lt;2 || isempty(Nderiv)
1044                 Nderiv=2;
1045             <span class="keyword">end</span>
1046             <span class="keyword">if</span> nargin&lt;3 || isempty(Nreg)
1047                Nreg=2;
1048             <span class="keyword">end</span>
1049             <span class="keyword">for</span> i=1:size(this.Data,2)
1050                this.Data(:,i)=monoLS(this.Data(:,i),[],Nderiv,Nreg);
1051             <span class="keyword">end</span>
1052             newThis=this;
1053         <span class="keyword">end</span>
1054 
1055         <a name="_sub53" href="#_subfunctions" class="code">function this=medianFilter(this,N)</a>
1056             <span class="keyword">if</span> mod(N,2)==0
1057                 error(<span class="string">'Only odd filter orders are allowed'</span>)
1058                 <span class="comment">%This actually works with even orders, but then the data</span>
1059                 <span class="comment">%gets shifted by half a sample, which is undesirable.</span>
1060             <span class="keyword">end</span>
1061 
1062             <span class="comment">%this.Data=medfilt1(this.Data,N,1,'omitnan'); %altered 12/4/2015 &quot;omitnan&quot; is not a valid input to medfilt1 in 2015a, 'omitnan' allowed for the median to be taken among the non-NaN elemets</span>
1063             this.Data=medfilt1(double(this.Data),double(N),double(1)); <span class="comment">%This back-compatible alternative works as if the last argument were 'includenan' (i.e. whenever there is a NaN in the window, the result is NaN)</span>
1064             <span class="comment">%Setting the samples outside the filter to NaN:</span>
1065             this.Data(1:floor(N/2),:)=NaN;
1066             this.Data(end-floor(N/2)+1:<span class="keyword">end</span>,:)=NaN;
1067         <span class="keyword">end</span>
1068 
1069     <span class="keyword">end</span>
1070 
1071     methods(Hidden)
1072         <a name="_sub54" href="#_subfunctions" class="code">function newThis=resampleLogical(this,newTs, newT0,newN)</a>
1073             <span class="comment">%newN=floor((this.Time(end)-newT0)/newTs +1);</span>
1074             <span class="comment">%Can this be deprecated in favor of resample with 'logical'</span>
1075             <span class="comment">%method?</span>
1076             newTime=[0:newN-1]*newTs+newT0;
1077             newN=length(newTime);
1078             newData=sparse([],[],false,newN,size(this.Data,2),newN);<span class="comment">% Sparse logical array of size newN x size(this.Data,2) and room for up to size(this.Data,2) true elements.</span>
1079            <span class="keyword">for</span> i=1:size(this.Data,2) <span class="comment">%Go over event labels</span>
1080                oldEventTimes=this.Time(this.Data(:,i)); <span class="comment">%Find time of old events</span>
1081                closestNewEventIndexes=round((oldEventTimes-newT0)/newTs) + 1; <span class="comment">%Find closest index in new event</span>
1082                <span class="keyword">if</span> any(closestNewEventIndexes&gt;newN) <span class="comment">%It could happen in case of down-sampling that the closest new index falls outside the range</span>
1083                    <span class="comment">%Option 1: set it to the last available sample (this</span>
1084                    <span class="comment">%would no longer be 'rounding')</span>
1085                    closestNewEventIndexes(closestNewEventIndexes&gt;newN)=newN;
1086                    <span class="comment">%Option 2: eliminate event, as it falls outside range.</span>
1087                    <span class="comment">%This may cause failure of other functions that rely on</span>
1088                    <span class="comment">%down-sampling of events not changing the number of</span>
1089                    <span class="comment">%events</span>
1090                    closestNewEventIndexes(closestNewEventIndexes&gt;newN)=[];
1091                <span class="keyword">end</span>
1092 
1093                newData(closestNewEventIndexes,i)=true;
1094            <span class="keyword">end</span>
1095            newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,newT0,newTs,this.labels);
1096         <span class="keyword">end</span>
1097         
1098         <a name="_sub55" href="#_subfunctions" class="code">function [ATS,bad,Data]=align_v2(this,eventTS,eventLabel,N)</a>
1099             <span class="comment">%Efficient &amp; robust substitute for legacy align()</span>
1100             eventTimes=labTimeSeries.getArrayedEvents(eventTS,eventLabel);
1101             expEventTimes=alignedTimeSeries.expandEventTimes(eventTimes',N);
1102             Data=permute(this.getSample(expEventTimes),[1,3,2]);
1103             bad=any(isnan(eventTimes(1:end-1,:)),2);
1104             ATS=alignedTimeSeries(0,1,Data,this.labels,N,eventLabel,eventTimes');
1105         <span class="keyword">end</span>
1106     <span class="keyword">end</span>
1107 
1108     methods(Static)
1109         this=createLabTSFromTimeVector(data,time,labels); <span class="comment">%Need to compute appropriate t0 and Ts constants and call the constructor. Tricky if time is not uniformly sampled.</span>
1110         
1111         <a name="_sub56" href="#_subfunctions" class="code">function eventTimes=getArrayedEvents(eventTS,eventLabel)</a>
1112            <span class="keyword">if</span> nargin&gt;1
1113                 eventList=eventTS.getDataAsVector(eventLabel);
1114            <span class="keyword">else</span>
1115                eventList=eventTS.Data(:,1);
1116            <span class="keyword">end</span>
1117            <span class="comment">%Check needed: is eventList binary?</span>
1118            N=size(eventList,2); <span class="comment">%Number of events &amp; intervals to be found</span>
1119            <span class="comment">%auxList=double(eventList)*2.^[0:N-1]'; %List all events in a single vector, by numbering them differently.</span>
1120 
1121             <span class="comment">%refIdxLst=find(auxList==1);</span>
1122             refIdxLst=find(eventList(:,1)); <span class="comment">%Alt definition, to match what is returned if a single event was provided</span>
1123             M=length(refIdxLst)-1;
1124             auxTime=eventTS.Time;
1125             initTime=auxTime(refIdxLst); <span class="comment">%Initial time of each interval identified</span>
1126             eventTimes=nan(M+1,N); <span class="comment">%Duration of each interval</span>
1127             eventTimes(:,1)=initTime;
1128             <span class="keyword">for</span> i=1:M <span class="comment">%Going over strides</span>
1129                 t0=auxTime(refIdxLst(i));
1130                 lastEventIdx=refIdxLst(i);
1131                 <span class="keyword">for</span> j=1:N-1 <span class="comment">%Going over events</span>
1132                    <span class="comment">%nextEventIdx=lastEventIdx+find(auxList(lastEventIdx+1:refIdxLst(i+1)-1)==2^mod(j,N),1,'first');</span>
1133                    nextEventIdx=lastEventIdx+find(eventList(lastEventIdx+1:refIdxLst(i+1)-1,j+1),1,<span class="string">'first'</span>);
1134                    t1= auxTime(nextEventIdx); <span class="comment">%Look for next event</span>
1135                    <span class="keyword">if</span> ~isempty(t1) &amp;&amp; ~isempty(t0)
1136                        eventTimes(i,j+1)=t1;
1137                         lastEventIdx=nextEventIdx;
1138                    <span class="keyword">end</span>
1139 
1140                 <span class="keyword">end</span>
1141             <span class="keyword">end</span>
1142         <span class="keyword">end</span>
1143 
1144         <a name="_sub57" href="#_subfunctions" class="code">function [alignedTS,originalDurations]=stridedTSToAlignedTS(stridedTS,N) </a>
1145             error(<span class="string">'Deprecated. Use labTS.align()'</span>)
1146             <span class="comment">%To be used after splitByEvents</span>
1147             <span class="keyword">if</span> numel(stridedTS)~=0
1148                 <span class="keyword">if</span> ~islogical(stridedTS{1}.Data)
1149                     aux=zeros(sum(N),size(stridedTS{1}.Data,2),size(stridedTS,1));
1150                 <span class="keyword">else</span>
1151                     aux=false(sum(N),size(stridedTS{1}.Data,2),size(stridedTS,1));
1152                 <span class="keyword">end</span>
1153                 Nstrides=size(stridedTS,1);
1154                 Nphases=size(stridedTS,2);
1155                 originalDurations=nan(Nstrides,Nphases);
1156                 <span class="keyword">for</span> i=1:Nstrides <span class="comment">%Going over strides</span>
1157                     M=[0,cumsum(N)];
1158                     <span class="keyword">for</span> j=1:Nphases <span class="comment">%Going over aligned phases</span>
1159                         <span class="keyword">if</span> isa(stridedTS{i,j},<span class="string">'labTimeSeries'</span>)
1160                             originalDurations(i,j)=stridedTS{i,j}.timeRange;
1161                             <span class="keyword">if</span> ~isempty(stridedTS{i,j}.Data) &amp;&amp; sum(~isnan(stridedTS{i,j}.Data(:,1)))&gt;1
1162                                 aa=<a href="#_sub12" class="code" title="subfunction newThis=resampleN(this,newN,method)">resampleN</a>(stridedTS{i,j},N(j));
1163                                 aux(M(j)+1:M(j+1),:,i)=aa.Data;
1164                             <span class="keyword">else</span> <span class="comment">%Separating by strides returned empty labTimeSeries, possibly because of events in disorder</span>
1165                                 <span class="keyword">if</span> islogical(stridedTS{i,j}.Data)
1166                                     aux(M(j)+1:M(j+1),:,i)=false;
1167                                 <span class="keyword">else</span>
1168                                     aux(M(j)+1:M(j+1),:,i)=NaN;
1169                                 <span class="keyword">end</span>
1170                             <span class="keyword">end</span>
1171                         <span class="keyword">else</span>
1172                             error(<span class="string">'labTimeSeries:stridedTSToAlignedTS'</span>,[<span class="string">'First argument is not a cell array of labTimeSeries. Element i='</span> num2str(i) <span class="string">', j='</span> num2str(j)])
1173                         <span class="keyword">end</span>
1174                     <span class="keyword">end</span>
1175                 <span class="keyword">end</span>
1176                 alignmentLabels=cell(size(N)); <span class="comment">%Need to populate this field properly</span>
1177                 alignedTS=alignedTimeSeries(0,1,aux,stridedTS{1}.labels,N,alignmentLabels); <span class="comment">%On May 2nd 2017, Pablo changed to have sampling time =1 [time vector now counts samples]</span>
1178             <span class="keyword">else</span>
1179                 alignmentLabels=cell(size(N));
1180                 alignedTS=alignedTimeSeries(0,1,zeros(0,0),[],N,alignmentLabels);
1181                 originalDurations=[];
1182             <span class="keyword">end</span>
1183         <span class="keyword">end</span>
1184 
1185         <a name="_sub58" href="#_subfunctions" class="code">function [figHandle,plotHandles]=plotStridedTimeSeries(stridedTS,figHandle,plotHandles)</a>
1186                 <span class="keyword">if</span> nargin&lt;2
1187                     figHandle=[];
1188                 <span class="keyword">end</span>
1189                 <span class="keyword">if</span> nargin&lt;3
1190                     plotHandles=[];
1191                 <span class="keyword">end</span>
1192                N=2^ceil(log2(1.5/stridedTS{1}.sampPeriod));
1193                structure=labTimeSeries.stridedTSToAlignedTS(stridedTS,N);
1194                [figHandle,plotHandles]=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(structure,figHandle,plotHandles); <span class="comment">%Using the alignedTimeSeries plot function</span>
1195         <span class="keyword">end</span>
1196 
1197         <a name="_sub59" href="#_subfunctions" class="code">function this=join(labTSCellArray)</a>
1198             masterSampPeriod=labTSCellArray{1}.sampPeriod;
1199             masterLabels=labTSCellArray{1}.labels;
1200             newData=labTSCellArray{1}.Data;
1201            <span class="keyword">for</span> i=2:length(labTSCellArray(:))
1202                <span class="comment">%Check sampling rate &amp; dimensions are consistent, and append</span>
1203                <span class="comment">%at end of data</span>
1204                <span class="keyword">if</span> all(cellfun(@strcmp,masterLabels,labTSCellArray{i}.labels)) &amp;&amp; masterSampPeriod==labTSCellArray{i}.sampPeriod
1205                    newData=[newData;labTSCellArray{i}.Data];
1206                <span class="keyword">else</span>
1207                   warning([num2str(i) <span class="string">'-th element of input cell array does not have labels or sampling period consistent with other elements.'</span>]);
1208                <span class="keyword">end</span>
1209                this=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,labTSCellArray{1}.Time(1),masterSampPeriod,masterLabels);
1210            <span class="keyword">end</span>
1211         <span class="keyword">end</span>
1212     <span class="keyword">end</span>
1213 
1214 
1215 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 06-Jun-2024 12:15:54 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>