<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of labTimeSeries</title>
  <meta name="keywords" content="labTimeSeries">
  <meta name="description" content="">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003-2019 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">classes</a> &gt; <a href="../index.html">labTS</a> &gt; <a href="index.html">@labTimeSeries</a> &gt; labTimeSeries.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for classes/labTS/@labTimeSeries&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>labTimeSeries
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong></strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>This is a script file. </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>	</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>	</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function this=labTimeSeries(data,t0,Ts,labels)</a></li><li><a href="#_sub2" class="code">function [data,time,auxLabel]=getDataAsVector(this,label)</a></li><li><a href="#_sub3" class="code">function [newTS,auxLabel]=getDataAsTS(this,label)</a></li><li><a href="#_sub4" class="code">function labelList=getLabels(this)</a></li><li><a href="#_sub5" class="code">function this=renameLabels(this,originalLabels,newLabels)</a></li><li><a href="#_sub6" class="code">function labelList=getLabelsThatMatch(this,exp)</a></li><li><a href="#_sub7" class="code">function [boolFlag,labelIdx]=isaLabel(this,label)</a></li><li><a href="#_sub8" class="code">function data=getSample(this,timePoints,method)</a></li><li><a href="#_sub9" class="code">function newTS=synchTo(this,otherTS)</a></li><li><a href="#_sub10" class="code">function index=getIndexClosestToTimePoint(this,timePoints)</a></li><li><a href="#_sub11" class="code">function newThis=resample(this,newTs,newT0,hiddenFlag)</a></li><li><a href="#_sub12" class="code">function newThis=resampleN(this,newN,method)</a></li><li><a href="#_sub13" class="code">function newThis=split(this,t0,t1)</a></li><li><a href="#_sub14" class="code">function newThis=appendData(this,newData,newLabels)</a></li><li><a href="#_sub15" class="code">function [newThis,newData]=addNewParameter(this,newParamLabel,funHandle,inputParameterLabels)</a></li><li><a href="#_sub16" class="code">function [newData]=computeNewParameter(this,newParamLabel,funHandle,inputParameterLabels)</a></li><li><a href="#_sub17" class="code">function newThis=removeParameter(labels)</a></li><li><a href="#_sub18" class="code">function newThis=castAsOTS(this,orientation)</a></li><li><a href="#_sub19" class="code">function newThis=castAsSTS(this,F,tWin,tOverlap)</a></li><li><a href="#_sub20" class="code">function [data,time,auxLabel]=getPartialDataAsVector(this,label,t0,t1)</a></li><li><a href="#_sub21" class="code">function [steppedDataArray,bad,initTime,eventTimes]=splitByEvents(this,eventTS,eventLabel,timeMargin)</a></li><li><a href="#_sub22" class="code">function [slicedTS,initTime,duration]=sliceTS(this,timeBreakpoints,timeMargin)</a></li><li><a href="#_sub23" class="code">function this=times(this,constant)</a></li><li><a href="#_sub24" class="code">function this=rectify(this)</a></li><li><a href="#_sub25" class="code">function newThis=plus(this,other)</a></li><li><a href="#_sub26" class="code">function newThis=minus(this,other)</a></li><li><a href="#_sub27" class="code">function newThis=derivate(this)</a></li><li><a href="#_sub28" class="code">function [newThis,lag]=derivative(this,diffOrder)</a></li><li><a href="#_sub29" class="code">function newThis=integrate(this,initValues)</a></li><li><a href="#_sub30" class="code">function newthis=equalizeEnergyPerChannel(this)</a></li><li><a href="#_sub31" class="code">function newthis=equalizeVarPerChannel(this)</a></li><li><a href="#_sub32" class="code">function newthis=demean(this)</a></li><li><a href="#_sub33" class="code">function this=fillts(this)</a></li><li><a href="#_sub34" class="code">function newThis=concatenate(this,other)</a></li><li><a href="#_sub35" class="code">function newThis=cat(this,other)</a></li><li><a href="#_sub36" class="code">function this=substituteNaNs(this,method)</a></li><li><a href="#_sub37" class="code">function newThis=thresholdByChannel(this,th,label,moreThanFlag)</a></li><li><a href="#_sub38" class="code">function fs=get.sampFreq(this)</a></li><li><a href="#_sub39" class="code">function tr=get.timeRange(this)</a></li><li><a href="#_sub40" class="code">function Nsamp=get.Nsamples(this)</a></li><li><a href="#_sub41" class="code">function [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth)</a></li><li><a href="#_sub42" class="code">function [h,plotHandles]=plotAligned(this,h,labels,plotHandles,events,color,lineWidth)</a></li><li><a href="#_sub43" class="code">function [h,plotHandles]=bilateralPlot(this,h,labels,plotHandles,events,color,lineWidth)</a></li><li><a href="#_sub44" class="code">function h=dispCov(this)</a></li><li><a href="#_sub45" class="code">function [fh,ph,missing]=assessMissing(this,labels,fh,ph)</a></li><li><a href="#_sub46" class="code">function [newThis,logL]=findOutliers(this,model,verbose)</a></li><li><a href="#_sub47" class="code">function Fthis=fourierTransform(this,M)</a></li><li><a href="#_sub48" class="code">function Sthis=spectrogram(this,labels,nFFT,tWin,tOverlap)</a></li><li><a href="#_sub49" class="code">function [ATS,bad]=align(this,eventTS,eventLabel,N,~)</a></li><li><a href="#_sub50" class="code">function [DTS,bad]=discretize(this,eventTS,eventLabel,N,summaryFunction)</a></li><li><a href="#_sub51" class="code">function newThis=lowPassFilter(this,fcut)</a></li><li><a href="#_sub52" class="code">function newThis=highPassFilter(this,fcut)</a></li><li><a href="#_sub53" class="code">function newThis=monotonicFilter(this,Nderiv,Nreg)</a></li><li><a href="#_sub54" class="code">function this=medianFilter(this,N)</a></li><li><a href="#_sub55" class="code">function newThis=resampleLogical(this,newTs, newT0,newN)</a></li><li><a href="#_sub56" class="code">function [ATS,bad,Data]=align_v2(this,eventTS,eventLabel,N)</a></li><li><a href="#_sub57" class="code">function eventTimes=getArrayedEvents(eventTS,eventLabel)</a></li><li><a href="#_sub58" class="code">function [alignedTS,originalDurations]=stridedTSToAlignedTS(stridedTS,N)</a></li><li><a href="#_sub59" class="code">function [figHandle,plotHandles]=plotStridedTimeSeries(stridedTS,figHandle,plotHandles)</a></li><li><a href="#_sub60" class="code">function this=join(labTSCellArray)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 classdef <a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>  &lt; timeseries
0002     <span class="comment">%labTimeSeries  Extends timeseries (built-in MATLAB class) to meet</span>
0003     <span class="comment">%               our lab's needs for storing data. Forces timeseries to</span>
0004     <span class="comment">%               be uniformly sampled.</span>
0005     <span class="comment">%</span>
0006     <span class="comment">%labTimeSeries properties:</span>
0007     <span class="comment">%   labels - cell array of strings with labels for the columns of Data</span>
0008     <span class="comment">%   sampPeriod - time between samples, equal to 1/sampFreq</span>
0009     <span class="comment">%   sampFreq - sampling rate in Hz, equal to 1/sampPeriod</span>
0010     <span class="comment">%   Nsamples - total number of samples in timeSeries</span>
0011     <span class="comment">%   Data - matrix of data values, size is Nsamples x length(labels)</span>
0012     <span class="comment">%   Time - time values corresponding to each sample</span>
0013     <span class="comment">%   Length - should be same as Nsamples</span>
0014     <span class="comment">%</span>
0015     <span class="comment">%labTimeSeries methods:</span>
0016     <span class="comment">%   getDataAsVector - get a vector of data for a given label</span>
0017     <span class="comment">%   getDataAsTS - returns a new labTimeSeries with data for given label(s)</span>
0018     <span class="comment">%   getLabels - returns list of labels</span>
0019     <span class="comment">%   getLabelsThatMatch - returns list of labels that match a given string</span>
0020     <span class="comment">%   isaLabel - checks if a string is contained in label array</span>
0021     <span class="comment">%   getSample - samples the timeseries at arbitrary timepoints</span>
0022     <span class="comment">%   resample - resamples timeseries to a different sampling period</span>
0023     <span class="comment">%   split - returns a timeseries containing the data between to given timepoints</span>
0024     <span class="comment">%   appendData - adds more data to the timeseries (As new 'labels')</span>
0025     <span class="comment">%   addNewParameter - adds data to TS computing it from existing data</span>
0026     <span class="comment">%   getPartialDataAsVector - returns data corresponding to some labels in matrix form</span>
0027     <span class="comment">%   splitByEvents - separates the timeseries according to the events given in an event (boolean) timeseries</span>
0028     <span class="comment">%   derivate - differentiates the timeseries in time</span>
0029     <span class="comment">%   fillts - substitutes NaN values by interpolation</span>
0030     <span class="comment">%   concatenate/cat - merges two timeseries into a single one</span>
0031     <span class="comment">%   lowPassFilter - what the name says</span>
0032     <span class="comment">%   highPassFilter - what the name says</span>
0033     <span class="comment">%   monotonicFilter - calls monoLS on the data for each column</span>
0034     <span class="comment">%   medianFilter - what the name says</span>
0035     <span class="comment">%   FourierTransform - what the name says</span>
0036     <span class="comment">%   plot - plots data</span>
0037 
0038     <span class="comment">%%</span>
0039     properties(SetAccess=private)
0040         labels={<span class="string">''</span>};
0041         sampPeriod;
0042     <span class="keyword">end</span>
0043     properties(Dependent)
0044         sampFreq
0045         timeRange
0046         Nsamples
0047     <span class="keyword">end</span>
0048 
0049     <span class="comment">%%</span>
0050     methods
0051 
0052         <span class="comment">%Constructor:</span>
0053         <a name="_sub0" href="#_subfunctions" class="code">function this=labTimeSeries(data,t0,Ts,labels) </a><span class="comment">%Necessarily uniformly sampled</span>
0054             <span class="keyword">if</span> nargin==0
0055                 data=[];
0056                 time=[];
0057                 labels={};
0058                 Ts=[];
0059             <span class="keyword">else</span>
0060                 time=[0:size(data,1)-1]*Ts+t0';
0061             <span class="keyword">end</span>
0062             this=this@timeseries(data,time);
0063             this.sampPeriod=Ts;
0064             <span class="keyword">if</span> (length(labels)==size(data,2)) &amp;&amp; isa(labels,<span class="string">'cell'</span>)
0065                 this.labels=labels;
0066             <span class="keyword">else</span>
0067                 ME=MException(<span class="string">'labTimeSeries:ConstructorInconsistentArguments'</span>,<span class="string">'The size of the labels array is inconsistent with the data being provided.'</span>);
0068                 throw(ME)
0069             <span class="keyword">end</span>
0070             <span class="comment">%Check for repeat labels:</span>
0071             [~,i1,i2]=unique(lower(labels));
0072             <span class="keyword">if</span> length(i1)&lt;length(labels)
0073                 repIdx=find((sort(i1)-[1:length(i1)]')~=0,1,<span class="string">'first'</span>);
0074                 <span class="keyword">if</span> isempty(repIdx)
0075                     repIdx=length(i1)+1;
0076                 <span class="keyword">end</span>
0077                 ME=MException(<span class="string">'labTimeSeries:ConstructorRepeatedLabels'</span>,[<span class="string">'Found '</span> num2str(length(labels)-length(i1)) <span class="string">' collisions of label names. First collision is: '</span> labels{repIdx}]);
0078                     throw(ME)
0079             <span class="keyword">end</span>
0080         <span class="keyword">end</span>
0081 
0082         <span class="comment">%-------------------</span>
0083 
0084         <span class="comment">%Other I/O functions:</span>
0085         <a name="_sub1" href="#_subfunctions" class="code">function [data,time,auxLabel]=getDataAsVector(this,label)</a>
0086             <span class="keyword">if</span> nargin&lt;2 || isempty(label)
0087                 label=this.labels;
0088             <span class="keyword">end</span>
0089             <span class="keyword">if</span> isa(label,<span class="string">'char'</span>)
0090                 auxLabel={label};
0091             <span class="keyword">else</span>
0092                 auxLabel=label;
0093             <span class="keyword">end</span>
0094             time=this.Time;
0095             [boolFlag,labelIdx]=this.isaLabel(auxLabel);
0096             <span class="keyword">if</span> ~any(boolFlag)
0097                 auxLabel2=[];
0098                 <span class="keyword">for</span> i=1:length(auxLabel)
0099                     auxLabel2=[auxLabel2 this.getLabelsThatMatch(auxLabel{i})];
0100                 <span class="keyword">end</span>
0101                 [boolFlag,labelIdx]=this.isaLabel(auxLabel2);
0102                 NN=numel(auxLabel2);
0103                 warning([<span class="string">'None of the provided labels are a parameter in this timeSeries. Trying to return labels that match the provided label as a regular expression: found '</span> num2str(NN) <span class="string">' matches.'</span>])
0104                 <span class="keyword">else</span>
0105                     <span class="keyword">for</span> i=1:length(boolFlag)
0106                         <span class="keyword">if</span> ~boolFlag(i)
0107                             warning([<span class="string">'Label '</span> auxLabel{i} <span class="string">' is not a labeled dataset in this timeSeries.'</span>])
0108                         <span class="keyword">end</span>
0109                     <span class="keyword">end</span>
0110                 <span class="keyword">end</span>
0111 
0112             data=this.Data(:,labelIdx(boolFlag));
0113             <span class="keyword">if</span> nargout&gt;2
0114                 auxLabel=this.labels(labelIdx(boolFlag));
0115             <span class="keyword">end</span>
0116         <span class="keyword">end</span>
0117 
0118         <a name="_sub2" href="#_subfunctions" class="code">function [newTS,auxLabel]=getDataAsTS(this,label)</a>
0119             [data,time,auxLabel]=<a href="#_sub2" class="code" title="subfunction [data,time,auxLabel]=getDataAsVector(this,label)">getDataAsVector</a>(this,label);
0120             newTS=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(data,time(1),this.sampPeriod,auxLabel);
0121         <span class="keyword">end</span>
0122 
0123         <a name="_sub3" href="#_subfunctions" class="code">function labelList=getLabels(this)</a>
0124            labelList=this.labels;
0125         <span class="keyword">end</span>
0126         
0127         <a name="_sub4" href="#_subfunctions" class="code">function this=renameLabels(this,originalLabels,newLabels)</a>
0128             warning(<span class="string">'labTS:renameLabels:dont'</span>,<span class="string">'You should not be renaming the labels. You have been warned.'</span>)
0129             <span class="keyword">if</span> isempty(originalLabels)
0130                 originalLabels=this.labels;
0131             <span class="keyword">end</span>
0132             <span class="keyword">if</span> size(newLabels)~=size(originalLabels)
0133                 error(<span class="string">'Inconsistent label sizes'</span>)
0134             <span class="keyword">end</span>
0135             [boo,idx]=this.isaLabel(originalLabels);
0136             this.labels(idx(boo))=newLabels(boo);
0137         <span class="keyword">end</span>
0138 
0139         <a name="_sub5" href="#_subfunctions" class="code">function labelList=getLabelsThatMatch(this,exp)</a>
0140             <span class="comment">%Returns labels on this labTS that match the regular expression exp.</span>
0141             <span class="comment">%labelList=getLabelsThatMatch(this,exp)</span>
0142             <span class="comment">%INPUT:</span>
0143             <span class="comment">%this: labTS object</span>
0144             <span class="comment">%exp: any regular expression (as string).</span>
0145             <span class="comment">%OUTPUT:</span>
0146             <span class="comment">%labelList: cell array containing labels of this labTS that match</span>
0147             <span class="comment">%See also regexp</span>
0148             labelList=this.labels;
0149             flags=cellfun(@(x) ~isempty(x),regexp(labelList,exp));
0150             labelList=labelList(flags);
0151         <span class="keyword">end</span>
0152 
0153         <a name="_sub6" href="#_subfunctions" class="code">function [boolFlag,labelIdx]=isaLabel(this,label)</a>
0154             <span class="keyword">if</span> isa(label,<span class="string">'char'</span>)
0155                 auxLabel{1}=label;
0156             <span class="keyword">elseif</span> isa(label,<span class="string">'cell'</span>)
0157                 auxLabel=label;
0158             <span class="keyword">else</span>
0159                 error(<span class="string">'labTimeSeries:isaLabel'</span>,<span class="string">'label input argument has to be a string or a cell array containing strings.'</span>)
0160             <span class="keyword">end</span>
0161             auxLabel=auxLabel(:);
0162             N=length(auxLabel);
0163             M=length(this.labels);
0164             <span class="keyword">if</span> N==M &amp;&amp; all(strcmpi(auxLabel,this.labels(:))) <span class="comment">%Case in which the list is identical to the label list, save time by not calling find() recursively.</span>
0165                 <span class="comment">%If this is true, it saves about 50ms per call, or 5 secs every 100 calls</span>
0166                 <span class="comment">%If false, it adds a small overhead of less than .1ms per call, which is negligible compared to the loop that needs to be performed.</span>
0167                 boolFlag=true(N,1);
0168                 labelIdx=1:M;
0169             <span class="keyword">else</span>
0170                 [boolFlag,labelIdx] = compareListsFast(this.labels,auxLabel);
0171             <span class="keyword">end</span>
0172         <span class="keyword">end</span>
0173 
0174         <a name="_sub7" href="#_subfunctions" class="code">function data=getSample(this,timePoints,method) </a><span class="comment">%This does not seem efficient: we are creating a timeseries object (from native Matlab) and using its resample method.</span>
0175             <span class="keyword">if</span> nargin&lt;3 || isempty(method)
0176                 <span class="keyword">if</span> isa(this.Data,<span class="string">'logical'</span>)
0177                     method=<span class="string">'closest'</span>;
0178                 <span class="keyword">else</span>
0179                     method=<span class="string">'linear'</span>;
0180                 <span class="keyword">end</span>
0181             <span class="keyword">end</span>
0182 
0183             <span class="keyword">if</span> ~isempty(timePoints)
0184                 M=length(this.labels);
0185                 <span class="keyword">switch</span> method
0186                     <span class="keyword">case</span> <span class="string">'linear'</span>
0187                         data=nan(numel(timePoints),M);
0188                         notNaNIdxs=~isnan(timePoints) &amp; ~isinf(timePoints) &amp; timePoints&lt;this.Time(end) &amp; timePoints&gt;this.Time(1); <span class="comment">%Excluding NaNs, Infs and out-of-range times from interpolation.</span>
0189                         [notNaNTimes,sorting]=sort(timePoints(notNaNIdxs),<span class="string">'ascend'</span>);
0190                         newTS=<a href="#_sub11" class="code" title="subfunction newThis=resample(this,newTs,newT0,hiddenFlag)">resample</a>(this,notNaNTimes,this.Time(1),1); <span class="comment">%Using timeseres.resample which does linear interp by default</span>
0191 
0192                         newTS.Data(sorting,:)=newTS.Data;
0193                         data(notNaNIdxs,:)=newTS.Data;
0194                     <span class="keyword">case</span> <span class="string">'closest'</span>
0195                         data=nan(numel(timePoints),M);
0196                         aux=this.getIndexClosestToTimePoint(timePoints(:));
0197                         inds=~isnan(aux);
0198                         aux=aux(inds); <span class="comment">%Eliminating NaNs</span>
0199                         newData=this.Data(aux,:); <span class="comment">%This would be the new data in the simplest case.</span>
0200                         initData=newData;
0201                         <span class="comment">%But, if two samples map to the same timePoint (sub-sampling) and that timePoint corresponds</span>
0202                         <span class="comment">%to an event, just keep the closest one, to avoid repeating events.</span>
0203                         trueEventSamples=unique(aux(any(newData,2) &amp; [diff(aux);1]==0)); <span class="comment">%Unique samples that contain an event</span>
0204                         tt=this.Time(trueEventSamples);
0205                         <span class="keyword">for</span> i=1:length(trueEventSamples)
0206                             mappedInds=find(aux==trueEventSamples(i));
0207                             relevantTimePoints=timePoints(mappedInds);
0208                             Dt=abs(tt(i)-relevantTimePoints);
0209                             jj=find(Dt==min(Dt),1,<span class="string">'first'</span>); <span class="comment">%The find() is needed to resolve ties</span>
0210                             mappedInds(jj)=[];
0211                             newData(mappedInds,:)=0;
0212                         <span class="keyword">end</span>
0213                         
0214                         data(inds,:)=newData;
0215 <span class="comment">%                         %Sanity check, this can be deprecated if no errors</span>
0216 <span class="comment">%                         %found by Jan 1st 2018. [implemented Sept 11 2017]</span>
0217 <span class="comment">%                         %Check that #events did not change:</span>
0218 <span class="comment">%                         if any(sum(newData)~=sum(this.split(min(timePoints(:))-this.sampPeriod/2,max(timePoints(:))+this.sampPeriod).Data))</span>
0219 <span class="comment">%                             error('Something went wrong when resampling: number of events changed')</span>
0220 <span class="comment">%                         end</span>
0221 <span class="comment">%                         %Check that no event is present at a sample where</span>
0222 <span class="comment">%                         %it was previously not:</span>
0223 <span class="comment">%                         if any(any(newData &amp; ~initData))</span>
0224 <span class="comment">%                             error('Something went wrong when resampling: event location changed')</span>
0225 <span class="comment">%                         end</span>
0226                         <span class="comment">%TODO: add interpft1 interpolation as possible</span>
0227                         <span class="comment">%method, provided that the timepoints are equally</span>
0228                         <span class="comment">%spaced.</span>
0229                 <span class="keyword">end</span>
0230                 data=reshape(full(data),[size(timePoints),M]); <span class="comment">%Can't have sparse ND matrices (WHY??)</span>
0231             <span class="keyword">else</span>
0232                 data=[];
0233             <span class="keyword">end</span>
0234         <span class="keyword">end</span>
0235         
0236         <a name="_sub8" href="#_subfunctions" class="code">function newTS=synchTo(this,otherTS)</a>
0237            <span class="comment">%Resamples the timeseries assuring that the new time vector coincides with that of otherTS. Pads with NaN if necessary.</span>
0238            <span class="keyword">if</span> ~islogical(this.Data)
0239                 method=[];
0240            <span class="keyword">else</span>
0241                method=<span class="string">'closest'</span>;
0242            <span class="keyword">end</span>
0243            data=squeeze(this.getSample(otherTS.Time,method));
0244            newTS=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(data,otherTS.Time(1),otherTS.sampPeriod,this.labels);
0245         <span class="keyword">end</span>
0246 
0247         <a name="_sub9" href="#_subfunctions" class="code">function index=getIndexClosestToTimePoint(this,timePoints)</a>
0248             <span class="comment">%NaN returns NaN</span>
0249 
0250             <span class="comment">%aux=abs(bsxfun(@minus,this.Time(:),timePoints(:)'))&lt;=(this.sampPeriod/2+eps);</span>
0251             <span class="comment">%[ii,jj]=find(aux);</span>
0252             <span class="comment">%index=nan(size(timePoints));</span>
0253             <span class="comment">%index(jj)=ii;</span>
0254             index=round((timePoints(:)-this.Time(1))/this.sampPeriod)+1;
0255             index(index&lt;1)=1;
0256             index(index&gt;numel(this.Time))=numel(this.Time);
0257             index=reshape(index,size(timePoints));
0258             <span class="comment">%Check</span>
0259             <span class="comment">%if any(abs(this.Time(index(:))-timePoints(:))&gt;(this.sampPeriod/2-eps))</span>
0260             <span class="comment">%    error('Non consistent indexes found')</span>
0261             <span class="comment">%end</span>
0262         <span class="keyword">end</span>
0263         <span class="comment">%-------------------</span>
0264 
0265         <span class="comment">%Modifier functions:</span>
0266         <a name="_sub10" href="#_subfunctions" class="code">function newThis=resample(this,newTs,newT0,hiddenFlag)</a>
0267             this.Quality=[]; <span class="comment">%So that Quality is not resample if it exists.</span>
0268             <span class="keyword">if</span> nargin&lt;3 || isempty(newT0)
0269                 error(<span class="string">'labTS:resample'</span>,<span class="string">'Resampling using only the new sampling period as argument is no longer supported. Use resampleN if you want to interpolate keeping the exact same time range.'</span>)
0270             <span class="keyword">end</span>
0271             <span class="keyword">if</span> nargin&lt;4 || isempty(hiddenFlag) || hiddenFlag==0 <span class="comment">%hiddenFlag allows to do non-uniform sampling</span>
0272                 <span class="keyword">if</span> newTs&gt;this.sampPeriod <span class="comment">%Under-sampling! be careful of aliasing</span>
0273                     warning(<span class="string">'labTS:resample'</span>,<span class="string">'Under-sampling data, be careful of aliasing!'</span>);
0274                 <span class="keyword">end</span>
0275                 <span class="comment">%Commented on 4/4/2015 by Pablo. No longer think this is a</span>
0276                 <span class="comment">%good idea. If we are explicitly trying to do uniform</span>
0277                 <span class="comment">%resampling on the same range, should use resampleN.</span>
0278                 <span class="comment">%Otherwise, if we try to synch two signals, and there is an</span>
0279                 <span class="comment">%offset in initial time, this returns something else.</span>
0280 
0281                 newN=ceil(this.timeRange/newTs)+1;
0282                 <span class="comment">%newThis=resampleN(this,newN);</span>
0283                 newTime=newT0:newTs:this.Time(end);
0284                  <span class="keyword">if</span> ~isa(this.Data(1,1),<span class="string">'logical'</span>)
0285                         newThis=this.resample@timeseries(newTime);
0286                         newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newThis.Data,newThis.Time(1),newTs,this.labels);
0287                  <span class="keyword">else</span> <span class="comment">%logical timeseries</span>
0288                        newThis=<a href="#_sub55" class="code" title="subfunction newThis=resampleLogical(this,newTs, newT0,newN)">resampleLogical</a>(this,newTs,newT0,newN);
0289                        <span class="comment">%Can be this deprecated in favor of just using</span>
0290                        <span class="comment">%getSample() for a logical TS?</span>
0291                  <span class="keyword">end</span>
0292 
0293             <span class="keyword">elseif</span> hiddenFlag==1<span class="comment">% this allows for non-uniform resampling, and returns a timeseries object.</span>
0294                 newThis=this.resample@timeseries(newTs); <span class="comment">%Warning: Treating newTs argument as a vector containing timepoints, not a sampling period. The super-class resampling returns a super-class object.</span>
0295             <span class="keyword">else</span>
0296                 error(<span class="string">'labTS:resample'</span>,<span class="string">'HiddenFlag argument has to be 0 or 1'</span>);
0297             <span class="keyword">end</span>
0298         <span class="keyword">end</span>
0299 
0300         <a name="_sub11" href="#_subfunctions" class="code">function newThis=resampleN(this,newN,method)</a>
0301             <span class="comment">%Uniform resampling of data, over the same time range. This</span>
0302             <span class="comment">%keeps the initial time on the same value, and returns newN</span>
0303             <span class="comment">%time-samples in the time interval of the original timeseries</span>
0304             <span class="keyword">if</span> ~isempty(this.Data)
0305             <span class="keyword">if</span> nargin&lt;3 || isempty(method)
0306                  <span class="keyword">if</span> ~isa(this.Data(1,1),<span class="string">'logical'</span>)
0307                         method=<span class="string">'interpft'</span>;
0308                  <span class="keyword">else</span>
0309                      method=<span class="string">'logical'</span>;
0310                  <span class="keyword">end</span>
0311             <span class="keyword">end</span>
0312             modNewTs=this.timeRange/(newN);
0313             newTimeVec=[0:newN-1]*modNewTs+this.Time(1);
0314             <span class="keyword">switch</span> method
0315                 <span class="keyword">case</span> <span class="string">'interpft'</span>
0316                     allNaNIdxs=[];
0317                     <span class="keyword">if</span> any(isnan(this.Data(:)))
0318                         <span class="keyword">if</span> any(all(isnan(this.Data)))
0319                             allNaNIdxs=all(isnan(this.Data));
0320                             warning([<span class="string">'All data is NaNs for labels '</span> strcat(this.labels{allNaNIdxs},<span class="string">' '</span>) <span class="string">', not interpolating those: returning NaNs'</span>])
0321                         <span class="keyword">end</span>
0322                     <span class="keyword">end</span>
0323                     this.Data(:,allNaNIdxs)=0; <span class="comment">%Substituting 0's to allow the next line to run without problems</span>
0324                     <span class="keyword">if</span> any(isnan(this.Data(:))) <span class="comment">%Only if there are still NaNs after the previous step, we will substitute the missing data with linearly interpolated values</span>
0325                         warning(<span class="string">'Trying to interpolate data using Fourier Transform method (''interpft1''), but data contains NaNs (missing values) which will propagate to the full timeseries. Substituting NaNs with linearly interpolated data.'</span>)
0326                         this=<a href="#_sub36" class="code" title="subfunction this=substituteNaNs(this,method)">substituteNaNs</a>(this,<span class="string">'linear'</span>); <span class="comment">%Interpolate time-series that are not all NaN (this is, there are just some values missing)</span>
0327                     <span class="keyword">end</span>
0328                     newData=interpft1(this.Data,newN,1); <span class="comment">%Interpolation is done on a nice(r) way.</span>
0329                     newData(:,allNaNIdxs)=nan; <span class="comment">%Replacing the previously filled data with NaNs</span>
0330                 <span class="keyword">case</span> <span class="string">'logical'</span>
0331                    newThis=<a href="#_sub55" class="code" title="subfunction newThis=resampleLogical(this,newTs, newT0,newN)">resampleLogical</a>(this,modNewTs,this.Time(1),newN);
0332                    newData=newThis.Data;
0333                 <span class="keyword">otherwise</span> <span class="comment">%Method is 'linear', 'cubic' or any of the accepted methods for interp1</span>
0334                     newData=zeros(length(newTimeVec),size(this.Data,2));
0335                     <span class="keyword">for</span> i=1:size(this.Data,2)
0336                         newData(:,i)=interp1(this.Time,this.Data(:,i),newTimeVec,method,nan);
0337                     <span class="keyword">end</span>
0338             <span class="keyword">end</span>
0339             t0=this.Time(1);
0340             newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,t0,modNewTs,this.labels);
0341             <span class="keyword">else</span> <span class="comment">%this.Data==[]</span>
0342                 error(<span class="string">'labTimeSeries:resampleN'</span>,<span class="string">'Interpolating empty labTimeSeries,impossible.'</span>)
0343             <span class="keyword">end</span>
0344         <span class="keyword">end</span>
0345 
0346         <a name="_sub12" href="#_subfunctions" class="code">function newThis=split(this,t0,t1)</a>
0347 
0348             <span class="comment">%Need to test this chunk of code before enabling:</span>
0349             <span class="comment">%if isnan(t0) || isnan(t1)</span>
0350             <span class="comment">%    warning('labTS:split','One of the interval limits is NaN. Returning empty TS.')</span>
0351             <span class="comment">%    newTS=[];</span>
0352             <span class="comment">%    return</span>
0353             <span class="comment">%end</span>
0354 
0355            <span class="comment">%Check t0&gt;= Time(1)</span>
0356            <span class="comment">%Check t1&lt;= Time(end)</span>
0357            initT=this.Time(1)-eps;
0358            finalT=this.Time(end)+eps;
0359            <span class="keyword">if</span> ~(t0&gt;= initT &amp;&amp; t1&lt;=finalT)
0360                <span class="keyword">if</span> (t1&lt;initT) || (t0&gt;=finalT)
0361                    <span class="comment">%ME=MException('labTS:split','Given time interval is not (even partially) contained within the time series.');</span>
0362                    <span class="comment">%throw(ME)</span>
0363              warning(<span class="string">'LabTS:split'</span>,[<span class="string">'Requested interval ['</span> num2str(t0) <span class="string">','</span> num2str(t1) <span class="string">'] is fully outside the timeseries. Padding with NaNs.'</span>])
0364                <span class="keyword">else</span>
0365                    warning(<span class="string">'LabTS:split'</span>,[<span class="string">'Requested interval ['</span> num2str(t0) <span class="string">','</span> num2str(t1) <span class="string">'] is not completely contained in TimeSeries. Padding with NaNs.'</span>])
0366                <span class="keyword">end</span>
0367            <span class="keyword">end</span>
0368            <span class="comment">%Find portion of requested interval that falls within the</span>
0369            <span class="comment">%timeseries' time vector (if any).</span>
0370             i1=find(this.Time&gt;=t0,1);
0371             i2=find(this.Time&lt;t1,1,<span class="string">'last'</span>); <span class="comment">%Explicitly NOT including the final sample, so that the time series is returned as the semi-closed interval [t0, t1). This avoids repeated samples if we ask for [t0,t1) and then for [t1,t2)</span>
0372             <span class="keyword">if</span> isempty(i1) || isempty(i2) <span class="comment">%This happens when the whole timeseries is outside the range</span>
0373         i1=1;
0374         i2=0;
0375         <span class="keyword">elseif</span> i2&lt;i1 <span class="comment">%When this happens the last included sample precedes the first included one, which happens, because of rounding, when asking for a very small interval (smaller than the sample period).</span>
0376                 warning(<span class="string">'LabTS:split'</span>,[<span class="string">'Requested interval ['</span> num2str(t0) <span class="string">','</span> num2str(t1) <span class="string">'] falls completely within two samples: returning empty timeSeries.'</span>])
0377             <span class="keyword">end</span>
0378             <span class="comment">%In case the requested time interval is larger than the</span>
0379             <span class="comment">%timeseries' actual time vector, pad with NaNs:</span>
0380             <span class="keyword">if</span> (this.Time(1)-t0)&gt;eps <span class="comment">%Case we are requesting time-samples preceding the timeseries' start-time</span>
0381                 ia=floor((this.Time(1)-t0)/this.sampPeriod); <span class="comment">%Extra samples to be added at the beginning</span>
0382             <span class="keyword">else</span>
0383                 ia=0;
0384             <span class="keyword">end</span>
0385             <span class="keyword">if</span> (t1-this.Time(end))&gt; eps <span class="comment">%Case we are requesting time-samples following the timeseries' end-time</span>
0386                 ib=floor((t1-this.Time(end))/this.sampPeriod); <span class="comment">%Extra samples to be added at the end</span>
0387             <span class="keyword">else</span>
0388                 ib=0;
0389             <span class="keyword">end</span>
0390             <span class="keyword">if</span> ~islogical(this.Data(1,1))
0391                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>([nan(ia,size(this.Data,2)) ; this.Data(i1:i2,:); nan(ib,size(this.Data,2))],this.Time(i1)-this.sampPeriod*ia,this.sampPeriod,this.labels);
0392             <span class="keyword">else</span>
0393                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>([false(ia,size(this.Data,2)) ; this.Data(i1:i2,:); false(ib,size(this.Data,2))],this.Time(i1)-this.sampPeriod*ia,this.sampPeriod,this.labels);
0394             <span class="keyword">end</span>
0395             <span class="keyword">if</span> ~isempty(this.Quality)
0396                 newThis.QualityInfo=this.QualityInfo;
0397                 k=find(strcmp(this.QualityInfo.Description,<span class="string">'missing'</span>));
0398                 newThis.Quality=[k*ones(ia,size(this.Quality,2)) ; this.Quality(i1:i2,:); k*ones(ib,size(this.Quality,2))];
0399             <span class="keyword">end</span>
0400         <span class="keyword">end</span>
0401 
0402         <a name="_sub13" href="#_subfunctions" class="code">function newThis=appendData(this,newData,newLabels) </a><span class="comment">%For back compat</span>
0403             other=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,newLabels,this.Time(1),this.sampPeriod);
0404             newThis=<a href="#_sub35" class="code" title="subfunction newThis=cat(this,other)">cat</a>(this,other);
0405         <span class="keyword">end</span>
0406 
0407         <a name="_sub14" href="#_subfunctions" class="code">function [newThis,newData]=addNewParameter(this,newParamLabel,funHandle,inputParameterLabels)</a>
0408            <span class="comment">%This function allows to compute new parameters from other existing parameters and have them added to the data.</span>
0409            <span class="comment">%This is useful when trying out new parameters without having to</span>
0410            <span class="comment">%recompute all existing parameters.</span>
0411            <span class="comment">%INPUT:</span>
0412            <span class="comment">%newPAramLAbel: string with the name of the new parameter</span>
0413            <span class="comment">%funHandle: a function handle with N input variables, whose</span>
0414            <span class="comment">%result will be used to compute the new parameter</span>
0415            <span class="comment">%inputParameterLabels: the parameters that will replace each of</span>
0416            <span class="comment">%the variables in the funHandle</span>
0417            <span class="comment">%EXAMPLE:</span>
0418            <span class="comment">%See example in parameterSeries</span>
0419 
0420            [newData]=<a href="#_sub16" class="code" title="subfunction [newData]=computeNewParameter(this,newParamLabel,funHandle,inputParameterLabels)">computeNewParameter</a>(this,newParamLabel,funHandle,inputParameterLabels);
0421            newThis=<a href="#_sub14" class="code" title="subfunction newThis=appendData(this,newData,newLabels) ">appendData</a>(this,newData,{newParamLabel}) ;
0422         <span class="keyword">end</span>
0423         
0424         <a name="_sub15" href="#_subfunctions" class="code">function [newData]=computeNewParameter(this,newParamLabel,funHandle,inputParameterLabels)</a>
0425            <span class="comment">%This function allows to compute new parameters from other existing parameters and have them added to the data.</span>
0426            <span class="comment">%This is useful when trying out new parameters without having to</span>
0427            <span class="comment">%recompute all existing parameters.</span>
0428            <span class="comment">%INPUT:</span>
0429            <span class="comment">%newPAramLAbel: string with the name of the new parameter</span>
0430            <span class="comment">%funHandle: a function handle with N input variables, whose</span>
0431            <span class="comment">%result will be used to compute the new parameter</span>
0432            <span class="comment">%inputParameterLabels: the parameters that will replace each of</span>
0433            <span class="comment">%the variables in the funHandle</span>
0434            <span class="comment">%EXAMPLE:</span>
0435            <span class="comment">%See example in parameterSeries</span>
0436            <span class="comment">%See also: addNewParameter</span>
0437            
0438            <span class="comment">%TO DO: support many new parameters together, as long as they</span>
0439            <span class="comment">%use the same funHandle, with inputParameterLabels an NxM array,</span>
0440            <span class="comment">%where N is the size of newParamLabel (# parameters to be</span>
0441            <span class="comment">%computed). Use this change in</span>
0442            <span class="comment">%linearStretch(this,labels,rangeValues) for efficiency</span>
0443            
0444            <span class="comment">%Check input sanity:</span>
0445            <span class="keyword">if</span> length(inputParameterLabels)~=nargin(funHandle)
0446                error(<span class="string">'labTS:addNewParameter'</span>,<span class="string">'Number of input arguments in function handle and number of labels in inputParameterLabels should be the same'</span>)
0447            <span class="keyword">end</span>
0448            <span class="keyword">if</span> compareListsFast(this.labels,newParamLabel)
0449                error(<span class="string">'labTS:addNewParameter'</span>,<span class="string">'Cannot add parameter because it already exists'</span>)
0450            <span class="keyword">end</span>
0451            oldData=this.getDataAsVector(inputParameterLabels);
0452            str=<span class="string">'('</span>;
0453            <span class="keyword">for</span> i=1:size(oldData,2)
0454                str=[str <span class="string">'oldData(:,'</span> num2str(i) <span class="string">'),'</span>];
0455            <span class="keyword">end</span>
0456            str(end)=<span class="string">')'</span>; <span class="comment">%Replacing last comma with parenthesis</span>
0457            eval([<span class="string">'newData=funHandle'</span> str <span class="string">';'</span>]); <span class="comment">%Isn't there a way to do this without eval?</span>
0458         <span class="keyword">end</span>
0459         
0460         <a name="_sub16" href="#_subfunctions" class="code">function newThis=removeParameter(labels)</a>
0461             [bool,idxs] = compareLists(this.labels,labels);
0462             <span class="keyword">if</span> any(~bool)
0463                 warning([{<span class="string">'Could not remove some parameters because they are not present: '</span>} labels(~bool)])
0464             <span class="keyword">end</span>
0465             newThis=this;
0466             newThis.labels(idxs(bool))=[];
0467             newThis.Data(:,idxs(bool))=[];
0468         <span class="keyword">end</span>
0469 
0470         <a name="_sub17" href="#_subfunctions" class="code">function newThis=castAsOTS(this,orientation)</a>
0471             <span class="keyword">if</span> nargin&lt;2 || isempty(orientation)
0472                 orientation=orientationInfo;
0473             <span class="keyword">end</span>
0474             newThis=orientedLabTimeSeries(this.Data,this.Time(1),this.sampPeriod,this.labels,orientation);
0475         <span class="keyword">end</span>
0476         
0477         <a name="_sub18" href="#_subfunctions" class="code">function newThis=castAsSTS(this,F,tWin,tOverlap)</a>
0478             <span class="comment">%1) Check if it satisfies STS requirements</span>
0479             dataF=this.Data;
0480             labelsF=this.labels;
0481             t0=this.Time(1);
0482             Ts=this.sampPeriod;
0483             spectroTimeSeries.inputArgsCheck(dataF,labelsF,t0,Ts,F,tWin,tOverlap)
0484             newThis=spectroTimeSeries(dataF,labelsF,t0,Ts,F,tWin,tOverlap);
0485         <span class="keyword">end</span>
0486 
0487         <a name="_sub19" href="#_subfunctions" class="code">function [data,time,auxLabel]=getPartialDataAsVector(this,label,t0,t1)</a>
0488             newThis=<a href="#_sub13" class="code" title="subfunction newThis=split(this,t0,t1)">split</a>(this.getDataAsTS(label),t0,t1);
0489             [data,time,auxLabel]=<a href="#_sub2" class="code" title="subfunction [data,time,auxLabel]=getDataAsVector(this,label)">getDataAsVector</a>(newThis,label);
0490         <span class="keyword">end</span>
0491 
0492         <a name="_sub20" href="#_subfunctions" class="code">function [steppedDataArray,bad,initTime,eventTimes]=splitByEvents(this,eventTS,eventLabel,timeMargin)</a>
0493            <span class="comment">%eventTS needs to be a labTimeSeries with binary events as data</span>
0494            <span class="comment">%If eventLabel is not given, the first data column is used as</span>
0495            <span class="comment">%the relevant event marker. If given, eventLabel must be the</span>
0496            <span class="comment">%label of one of the data columns in eventTS</span>
0497 
0498            <span class="comment">%Check needed: is eventTS a labTimeSeries?</span>
0499            <span class="keyword">if</span> nargin&gt;2
0500                 eventList=eventTS.getDataAsVector(eventLabel);
0501            <span class="keyword">else</span>
0502                eventList=eventTS.Data(:,1);
0503            <span class="keyword">end</span>
0504            <span class="comment">%Check needed: is eventList binary?</span>
0505            N=size(eventList,2); <span class="comment">%Number of events &amp; intervals to be found</span>
0506            auxList=double(eventList)*2.^[0:N-1]'; <span class="comment">%List all events in a single vector, by numbering them differently.</span>
0507            <span class="comment">%</span>
0508            <span class="keyword">if</span> nargin&lt;4 || isempty(timeMargin)
0509                timeMargin=0;
0510            <span class="keyword">end</span>
0511 
0512            <span class="comment">%TODO: this needs to call on getArrayedEvents() to avoid</span>
0513            <span class="comment">%duplicating the event-finding logic</span>
0514            
0515             refIdxLst=find(auxList==1);
0516             M=length(refIdxLst)-1;
0517             auxTime=eventTS.Time;
0518             aa=auxTime(refIdxLst);
0519             initTime=aa(1:M); <span class="comment">%Initial time of each interval identified</span>
0520             eventTimes=nan(M,N); <span class="comment">%Duration of each interval</span>
0521             eventTimes(:,1)=initTime;
0522             steppedDataArray=cell(M,N);
0523             bad=false(M,1);
0524             <span class="keyword">for</span> i=1:M <span class="comment">%Going over strides</span>
0525                 t0=auxTime(refIdxLst(i));
0526                 nextT0=auxTime(refIdxLst(i+1));
0527                 lastEventIdx=refIdxLst(i);
0528                 <span class="keyword">for</span> j=1:N-1 <span class="comment">%Going over events</span>
0529                    nextEventIdx=lastEventIdx+find(auxList(lastEventIdx+1:refIdxLst(i+1)-1)==2^mod(j,N),1,<span class="string">'first'</span>);
0530                    t1= auxTime(nextEventIdx); <span class="comment">%Look for next event</span>
0531                    <span class="keyword">if</span> ~isempty(t1) &amp;&amp; ~isempty(t0)
0532                        eventTimes(i,j+1)=t1;
0533                         steppedDataArray{i,j}=this.split(t0-timeMargin,t1+timeMargin);
0534                         t0=t1;
0535                         lastEventIdx=nextEventIdx;
0536                    <span class="keyword">else</span>
0537                        warning([<span class="string">'Events were not in order on stride '</span> num2str(i) <span class="string">', returning empty labTimeSeries.'</span>])
0538                         <span class="keyword">if</span> islogical(this.Data)
0539                             steppedDataArray{i,j}=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(false(0,size(this.Data,2)),0,1,this.labels);
0540                         <span class="keyword">else</span>
0541                             steppedDataArray{i,j}=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(zeros(0,size(this.Data,2)),0,1,this.labels); <span class="comment">%Empty labTimeSeries</span>
0542                         <span class="keyword">end</span>
0543                         bad(i)=true;
0544                    <span class="keyword">end</span>
0545 
0546                 <span class="keyword">end</span>
0547                 steppedDataArray{i,N}=this.split(t0-timeMargin,nextT0+timeMargin); <span class="comment">%This line is executed for the last interval btw events, which is the only one when there is a single event separating (N=1).</span>
0548             <span class="keyword">end</span>
0549         <span class="keyword">end</span>
0550 
0551         <a name="_sub21" href="#_subfunctions" class="code">function [slicedTS,initTime,duration]=sliceTS(this,timeBreakpoints,timeMargin)</a>
0552           <span class="comment">%Slices a single timeseries into a cell array of smaller timeseries, breaking at the given timeBreakpoints</span>
0553           slicedTS=cell(1,length(timeBreakpoints)-1);
0554           <span class="keyword">for</span> i=1:length(timeBreakpoints)-1
0555               <span class="keyword">if</span> isnan(timeBreakpoints(i)) || isnan(timeBreakpoints(i+1)) || timeBreakpoints(i+1)&lt;timeBreakpoints(i)
0556                   warning(<span class="string">'off'</span>) <span class="comment">%Preventing overload of annoying warnings</span>
0557               <span class="keyword">end</span>
0558               slicedTS{i}=this.split(timeBreakpoints(i)-timeMargin,timeBreakpoints(i+1)+timeMargin);
0559               warning(<span class="string">'on'</span>)
0560           <span class="keyword">end</span>
0561             initTime=timeBreakpoints(1:end-1)-timeMargin;
0562             duration=diff(timeBreakpoints)+2*timeMargin;
0563         <span class="keyword">end</span>
0564 
0565         <a name="_sub22" href="#_subfunctions" class="code">function this=times(this,constant)</a>
0566             this.Data=this.Data .* constant;
0567             <span class="keyword">if</span> numel(constant)==1
0568                 s=num2str(constant);
0569             <span class="keyword">else</span>
0570                 s=<span class="string">'k'</span>; <span class="comment">%Generic constant string</span>
0571             <span class="keyword">end</span>
0572             this.labels=strcat([s <span class="string">'*'</span>],this.labels);
0573         <span class="keyword">end</span>
0574         
0575         <a name="_sub23" href="#_subfunctions" class="code">function this=rectify(this)</a>
0576             this.Data=abs(this.Data);
0577             this.labels=strcat(strcat(this.labels),<span class="string">'abs'</span>);
0578         <span class="keyword">end</span>
0579 
0580         <a name="_sub24" href="#_subfunctions" class="code">function newThis=plus(this,other)</a>
0581             M=size(this.Data,2);
0582             <span class="keyword">if</span> size(other.Data,2)~=M
0583                 error(<span class="string">'Inconsistent sizes for sum'</span>)
0584             <span class="keyword">end</span>
0585             newLabels=cell(size(this.labels));
0586             <span class="keyword">for</span> i=1:M
0587                 newLabels{i}=[<span class="string">'('</span> this.labels{i} <span class="string">' + '</span> other.labels{i} <span class="string">')'</span>];
0588             <span class="keyword">end</span>
0589             <span class="keyword">if</span> abs(this.Time(1)-other.Time(1))&lt;eps &amp;&amp; abs(this.sampPeriod-other.sampPeriod)&lt;eps &amp;&amp; length(this.labels)==length(other.labels)
0590                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(this.Data+other.Data,this.Time(1),this.sampPeriod,newLabels);
0591             <span class="keyword">else</span>
0592                 error(<span class="string">''</span>)
0593             <span class="keyword">end</span>
0594         <span class="keyword">end</span>
0595 
0596         <a name="_sub25" href="#_subfunctions" class="code">function newThis=minus(this,other)</a>
0597             <span class="comment">%Subtracts two labTSs</span>
0598             <span class="comment">%Could be deprecated in favor of: newThis=this + -1*other;</span>
0599             M=size(this.Data,2);
0600             <span class="keyword">for</span> i=1:M
0601                 newLabels{i}=[<span class="string">'('</span> this.labels{i} <span class="string">' - '</span> other.labels{i} <span class="string">')'</span>];
0602             <span class="keyword">end</span>
0603             <span class="keyword">if</span> abs(this.Time(1)-other.Time(1))&lt;eps &amp;&amp; abs(this.sampPeriod-other.sampPeriod)&lt;eps &amp;&amp; length(this.labels)==length(other.labels)
0604                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(this.Data-other.Data,this.Time(1),this.sampPeriod,newLabels);
0605             <span class="keyword">end</span>
0606         <span class="keyword">end</span>
0607 
0608         <a name="_sub26" href="#_subfunctions" class="code">function newThis=derivate(this)</a>
0609             <span class="comment">%This is kept for legacy compatibility purposes only</span>
0610             partialThis=this.derivative;
0611             pad=nan(1,size(this.Data,2));
0612             newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>([pad;partialThis.Data;pad],this.Time(1),this.sampPeriod,partialThis.labels);
0613         <span class="keyword">end</span>
0614         
0615         <a name="_sub27" href="#_subfunctions" class="code">function [newThis,lag]=derivative(this,diffOrder)</a>
0616             <span class="comment">%Numerical differentiation of labTS</span>
0617             <span class="comment">%diffOrder establishes the order of the filter used for</span>
0618             <span class="comment">%estimation, NOT higher order derivatives [we are approximating</span>
0619             <span class="comment">%an IIR filter -the true derivative- through a FIR].</span>
0620             <span class="comment">%Ref: https://en.wikipedia.org/wiki/Finite_difference_coefficient</span>
0621             <span class="keyword">if</span> nargin&lt;2 || isempty(diffOrder)
0622                 diffOrder=2; <span class="comment">%Default</span>
0623             <span class="keyword">end</span>
0624             lag=diffOrder/2;
0625             <span class="keyword">switch</span> diffOrder
0626                <span class="keyword">case</span> 1
0627                    w= [1 -1];
0628                <span class="keyword">case</span> 2
0629                    w=.5*[1 0 -1];
0630                <span class="keyword">case</span> 4
0631                    w=[-1 8 0 -8 1]/12;
0632                <span class="keyword">case</span> 6
0633                    w=[1 -9 45 0 -45 9 -1]/60;
0634                <span class="keyword">case</span> 8
0635                    w=[-1/56 4/21 -1 4 0 -4 1 -4/21 1/56]/5;
0636                <span class="keyword">otherwise</span>
0637                    error(<span class="string">'Order not supported'</span>)
0638             <span class="keyword">end</span>
0639 
0640             M=size(this.Data,2);
0641             newData=conv2(this.Data,w',<span class="string">'valid'</span>)/this.sampPeriod;
0642             <span class="comment">%newData=[nan(order,M);.5*(this.Data(3:end,:)-this.Data(1:end-2,:));nan(order,M)]/this.sampPeriod; %Centered differential</span>
0643             <span class="keyword">if</span> mod(diffOrder,2)==0 <span class="comment">%For even order differences, we can preserve the sampling of the time series, padding with NaN on the edges</span>
0644                 newT0=this.Time(1);
0645                 newData=<a href="#_sub35" class="code" title="subfunction newThis=cat(this,other)">cat</a>(1,nan(lag,size(newData,2)),newData,nan(lag,size(newData,2)));
0646             <span class="keyword">else</span>
0647                 newT0=this.Time(1)+lag*this.sampPeriod;
0648             <span class="keyword">end</span>
0649             newLabels=strcat(<span class="string">'d/dt'</span>,{<span class="string">' '</span>},this.labels);
0650             newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,newT0,this.sampPeriod,newLabels);
0651         <span class="keyword">end</span>
0652         
0653         <a name="_sub28" href="#_subfunctions" class="code">function newThis=integrate(this,initValues)</a>
0654             <span class="comment">%This is the inverse operator of derivative when used with</span>
0655             <span class="comment">%diffOrder=1;</span>
0656             M=size(this.Data,2);
0657             <span class="keyword">if</span> nargin&lt;2 || isempty(initValues)
0658                initValues=zeros(1,M);  <span class="comment">%Default initial condition = 0</span>
0659                <span class="comment">%Initial values represent the integrated data values HALF A</span>
0660                <span class="comment">%SAMPLE before the first sample of this.</span>
0661                <span class="comment">%</span>
0662             <span class="keyword">end</span>
0663             <span class="keyword">if</span> numel(initValues)~=M
0664                 error(<span class="string">'Initial values mismatch between Data and initValues'</span>)
0665             <span class="keyword">end</span>
0666             newData=bsxfun(@<a href="#_sub25" class="code" title="subfunction newThis=plus(this,other)">plus</a>,initValues(:)',cumsum([zeros(1,M); this.Data],1) * this.sampPeriod); 
0667             lag=-.5;
0668             newLabels=strcat(<span class="string">'\int'</span>,{<span class="string">' '</span>},this.labels,{<span class="string">' '</span>},<span class="string">'dt'</span>);
0669             newT0=this.Time(1)+lag*this.sampPeriod;
0670             newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,newT0,this.sampPeriod,newLabels);
0671         <span class="keyword">end</span>
0672 
0673         <a name="_sub29" href="#_subfunctions" class="code">function newthis=equalizeEnergyPerChannel(this)</a>
0674             <span class="comment">%Equalizes each channel such that the second moment of each</span>
0675             <span class="comment">%channel equals 1, E(x^2)=1</span>
0676             newthis=this;
0677             newthis.Data=bsxfun(@rdivide,this.Data,sqrt(nanmean(this.Data.^2,1)));
0678         <span class="keyword">end</span>
0679 
0680         <a name="_sub30" href="#_subfunctions" class="code">function newthis=equalizeVarPerChannel(this)</a>
0681             <span class="comment">%Equalizes each channel such that the second moment  about the mean of each</span>
0682             <span class="comment">%channel equals 1, E((x-E(x))^2)=1</span>
0683             newthis=this;
0684             newthis.Data=bsxfun(@rdivide,this.Data,sqrt(nanvar(this.Data,[],1)));
0685         <span class="keyword">end</span>
0686 
0687         <a name="_sub31" href="#_subfunctions" class="code">function newthis=demean(this)</a>
0688             newthis=this;
0689             newthis.Data=bsxfun(@<a href="#_sub26" class="code" title="subfunction newThis=minus(this,other)">minus</a>,this.Data,nanmean(this.Data));
0690         <span class="keyword">end</span>
0691 
0692         <a name="_sub32" href="#_subfunctions" class="code">function this=fillts(this) </a><span class="comment">%TODO: Deprecate</span>
0693             warning(<span class="string">'labTS.fillts is being deprecated. Use substituteNaNs instead.'</span>)
0694             this=<a href="#_sub36" class="code" title="subfunction this=substituteNaNs(this,method)">substituteNaNs</a>(this,<span class="string">'linear'</span>);
0695         <span class="keyword">end</span>
0696 
0697         <a name="_sub33" href="#_subfunctions" class="code">function newThis=concatenate(this,other)</a>
0698             <span class="comment">%Check if time vectors are the same</span>
0699             <span class="keyword">if</span> all(this.Time==other.Time)
0700                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>([this.Data,other.Data],this.Time(1),this.sampPeriod,[this.labels(:)', other.labels(:)']);
0701             <span class="keyword">else</span>
0702                 error(<span class="string">'labTimeSeries:concatenate'</span>,<span class="string">'Cannot concatenate timeseries with different Time vectors.'</span>)
0703             <span class="keyword">end</span>
0704         <span class="keyword">end</span>
0705         <a name="_sub34" href="#_subfunctions" class="code">function newThis=cat(this,other)</a>
0706             newThis=<a href="#_sub34" class="code" title="subfunction newThis=concatenate(this,other)">concatenate</a>(this,other);
0707         <span class="keyword">end</span>
0708 
0709         <a name="_sub35" href="#_subfunctions" class="code">function this=substituteNaNs(this,method)</a>
0710             <span class="keyword">if</span> nargin&lt;2 || isempty(method)
0711                 method=<span class="string">'linear'</span>;
0712             <span class="keyword">end</span>
0713             badColumns=sum(~isnan(this.Data))&lt;2;
0714             <span class="keyword">if</span> any(badColumns) <span class="comment">%Returns true if any TS contained in the data is all NaN</span>
0715                 <span class="comment">%FIXME: This throws an exception now, but it should just</span>
0716                 <span class="comment">%return all NaN labels as all NaN and substitute missing</span>
0717                 <span class="comment">%values in the others.</span>
0718                 warning(<span class="string">'labTimeSeries:substituteNaNs'</span>,<span class="string">'timeseries contains at least one label that is all (or all but one sample) NaN. Can''t replace those values (no data to use as reference), setting to 0.'</span>)
0719                 this.Data(:,badColumns)=0;
0720             <span class="keyword">end</span>
0721             <span class="comment">%this.Quality=zeros(size(this.Data),'int8');</span>
0722             aux=isnan(this.Data);
0723              <span class="keyword">for</span> i=1:size(this.Data,2) <span class="comment">%Going through labels</span>
0724                  auxIdx=aux(:,i);
0725                  this.Data(auxIdx,i)=interp1(this.Time(~auxIdx),this.Data(~auxIdx,i),this.Time(auxIdx),method,0); <span class="comment">%Extrapolation values are filled with 0,</span>
0726              <span class="keyword">end</span>
0727              <span class="comment">%Saving quality data (to mark which samples were interpolated):</span>
0728              this.Quality=int8(aux); <span class="comment">%Matlab's timeseries stores this as int8. I would have preferred a sparse array.</span>
0729              this.QualityInfo.Code=[0 1];
0730              this.QualityInfo.Description={<span class="string">'good'</span>,<span class="string">'missing'</span>};
0731         <span class="keyword">end</span>
0732 
0733         <a name="_sub36" href="#_subfunctions" class="code">function newThis=thresholdByChannel(this,th,label,moreThanFlag)</a>
0734             newThis=this;
0735             <span class="keyword">if</span> nargin&lt;4 || isempty(moreThanFlag) || moreThanFlag==0
0736                 newThis.Data(newThis.getDataAsVector(label)&lt;th,:)=0;
0737             <span class="keyword">elseif</span> moreThanFlag==1
0738                 newThis.Data(newThis.getDataAsVector(label)&gt;th,:)=0;
0739             <span class="keyword">end</span>
0740         <span class="keyword">end</span>
0741 
0742         <span class="comment">%------------------</span>
0743 
0744         <span class="comment">%Getters for dependent properties</span>
0745         <a name="_sub37" href="#_subfunctions" class="code">function fs=get.sampFreq(this)</a>
0746             fs=1/this.sampPeriod;
0747         <span class="keyword">end</span>
0748 
0749         <a name="_sub38" href="#_subfunctions" class="code">function tr=get.timeRange(this)</a>
0750             tr=(this.Nsamples)*this.sampPeriod;
0751         <span class="keyword">end</span>
0752 
0753         <a name="_sub39" href="#_subfunctions" class="code">function Nsamp=get.Nsamples(this)</a>
0754             Nsamp=this.TimeInfo.Length;
0755         <span class="keyword">end</span>
0756 
0757         <span class="comment">%Display</span>
0758         <a name="_sub40" href="#_subfunctions" class="code">function [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) </a><span class="comment">%Alternative plot: all the traces go in different axes</span>
0759             <span class="keyword">if</span> nargin&lt;2 || isempty(h)
0760                 h=figure;
0761             <span class="keyword">else</span>
0762                 figure(h)
0763             <span class="keyword">end</span>
0764             N=length(this.labels);
0765             <span class="keyword">if</span> nargin&lt;3 || isempty(labels)
0766                 relData=this.Data;
0767                 relLabels=this.labels;
0768                 <span class="keyword">if</span> ~isempty(this.Quality)
0769                     relQual=this.Quality==1;
0770                 <span class="keyword">else</span>
0771                     relQual=true(size(relData));
0772                 <span class="keyword">end</span>
0773             <span class="keyword">else</span>
0774                [relData,~,relLabels]=this.getDataAsVector(labels);
0775                N=size(relData,2);
0776             <span class="keyword">end</span>
0777             <span class="keyword">if</span> nargin&lt;4 || isempty(plotHandles) || length(plotHandles)&lt;length(relLabels)
0778                 [b,a]=getFigStruct(length(relLabels));
0779                 plotHandles=tight_subplot(b,a,[.05 .05],[.05 .05], [.05 .05]); <span class="comment">%External function</span>
0780             <span class="keyword">end</span>
0781             <span class="keyword">if</span> nargin&lt;7 || isempty(lineWidth)
0782                 lineWidth=2;
0783             <span class="keyword">end</span>
0784             ax2=[];
0785             h1=[];
0786             <span class="keyword">if</span> any(~isreal(relData(:)))
0787                 warning(<span class="string">'labTimeSeries:plot'</span>,<span class="string">'Data is complex, plotting the modulus only.'</span>)
0788                 relData=abs(relData);
0789             <span class="keyword">end</span>
0790             <span class="keyword">for</span> i=1:N
0791                 h1(i)=plotHandles(i);
0792                 subplot(h1(i))
0793                 hold on
0794                 <span class="keyword">if</span> nargin&lt;6 || isempty(color)
0795                     pp=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(this.Time,relData(:,i),<span class="string">'LineWidth'</span>,lineWidth);
0796                 <span class="keyword">else</span>
0797                     pp=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(this.Time,relData(:,i),<span class="string">'LineWidth'</span>,lineWidth,<span class="string">'Color'</span>,color);
0798                 <span class="keyword">end</span>
0799                 <span class="comment">%plot(this.Time(relQual(:,i)),relData(relQual(:,i),i),'rx')</span>
0800                 uistack(pp,<span class="string">'top'</span>)
0801                 ylabel(relLabels{i})
0802                 <span class="comment">%if i==ceil(N/2)</span>
0803                 <span class="comment">%    xlabel('Time (s)')</span>
0804                 <span class="comment">%end</span>
0805                 hold off
0806                 <span class="keyword">if</span> nargin&gt;4 &amp;&amp; ~isempty(events)
0807                     lls={<span class="string">'LHS'</span>,<span class="string">'RTO'</span>,<span class="string">'RHS'</span>,<span class="string">'LTO'</span>};
0808                     [ii,jj]=find(events.getDataAsTS(lls).Data);
0809                     [ii,iaux]=sort(ii);
0810                     jj=jj(iaux);
0811                     ax1=gca;
0812                     <span class="comment">%ax2(i) = axes('Position',ax1.Position,...</span>
0813                     <span class="comment">%'XAxisLocation','top',...</span>
0814                     <span class="comment">%'YAxisLocation','right',...</span>
0815                     <span class="comment">%'Color','none');%,'XColor','r','YColor','r');</span>
0816                     <span class="comment">%[tt,i2]=unique(events.Time(ii));</span>
0817                    set(ax1,<span class="string">'XTick'</span>,events.Time(ii),<span class="string">'XTickLabel'</span>,lls(jj))
0818                    grid on
0819                 <span class="keyword">end</span>
0820             <span class="keyword">end</span>
0821             <span class="comment">%linkaxes([h1,ax2],'x')</span>
0822             plotHandles=h1;
0823         <span class="keyword">end</span>
0824         
0825         <a name="_sub41" href="#_subfunctions" class="code">function [h,plotHandles]=plotAligned(this,h,labels,plotHandles,events,color,lineWidth)</a>
0826             error(<span class="string">'Unimplemented'</span>)
0827             <span class="comment">%First attempt: align the data to the first column of events</span>
0828             <span class="comment">%provided</span>
0829             <span class="keyword">for</span> i=1:length(ee)
0830                this.split(t1,t2).plot
0831             <span class="keyword">end</span>
0832         <span class="keyword">end</span>
0833 
0834         <a name="_sub42" href="#_subfunctions" class="code">function [h,plotHandles]=bilateralPlot(this,h,labels,plotHandles,events,color,lineWidth)</a>
0835             <span class="comment">%Ideally we would plot 'L' and 'R' timeseries on top of each</span>
0836             <span class="comment">%other, to do a bilateral comparison. Need to implement.</span>
0837             <span class="keyword">if</span> nargin&lt;2 || isempty(h)
0838                 h=figure;
0839             <span class="keyword">else</span>
0840                 figure(h)
0841             <span class="keyword">end</span>
0842             <span class="keyword">if</span> nargin&lt;5 || isempty(events)
0843                 events=[];
0844             <span class="keyword">end</span>
0845             <span class="keyword">if</span> nargin&lt;6 || isempty(color)
0846                 color=[];
0847             <span class="keyword">end</span>
0848             <span class="keyword">if</span> nargin&lt;3 || isempty(labels)
0849                 labels=this.labels;
0850             <span class="keyword">end</span>
0851             suffix=unique(cellfun(@(x) x(2:end),labels,<span class="string">'UniformOutput'</span>,false));
0852             <span class="keyword">if</span> nargin&lt;4 || isempty(plotHandles) || length(plotHandles)&lt;length(suffix)
0853                 [b,a]=getFigStruct(length(suffix));
0854                 plotHandles=tight_subplot(b,a,[.05 .05],[.05 .05], [.05 .05]); <span class="comment">%External function</span>
0855             <span class="keyword">end</span>
0856             <span class="keyword">if</span> nargin&lt;7 || isempty(lineWidth)
0857                 lineWidth=2;
0858             <span class="keyword">end</span>
0859             [h,plotHandles]=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(this,h,strcat(<span class="string">'L'</span>,suffix),plotHandles,events,color,lineWidth);
0860             [h,plotHandles]=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(this,h,strcat(<span class="string">'R'</span>,suffix),plotHandles,events,color,lineWidth);
0861             <span class="keyword">for</span> i=1:length(suffix)
0862                 subplot(plotHandles(i))
0863                 ylabel(suffix{i})
0864                 <span class="keyword">if</span> i==length(suffix)
0865                 legend(<span class="string">'L'</span>,<span class="string">'R'</span>)
0866                 <span class="keyword">end</span>
0867             <span class="keyword">end</span>
0868         <span class="keyword">end</span>
0869 
0870         <a name="_sub43" href="#_subfunctions" class="code">function h=dispCov(this)</a>
0871            h=figure;
0872            dd=cov(this.Data);
0873            imagesc(dd)
0874            set(gca,<span class="string">'XTick'</span>,1:length(this.labels),<span class="string">'XTickLabels'</span>,this.labels,<span class="string">'XTickLabelRotation'</span>,90,<span class="string">'YTick'</span>,1:length(this.labels),<span class="string">'YTickLabels'</span>,this.labels,<span class="string">'YTickLabelRotation'</span>,0)
0875            colorbar
0876            caxis([-1 1]*max(dd(:)));
0877         <span class="keyword">end</span>
0878         
0879         <a name="_sub44" href="#_subfunctions" class="code">function [fh,ph,missing]=assessMissing(this,labels,fh,ph)</a>
0880             noDisp=false;
0881             <span class="keyword">if</span> nargin&lt;3 || isempty(fh)
0882                 fh=figure();
0883             <span class="keyword">elseif</span> fh==-1
0884                 noDisp=true;
0885             <span class="keyword">else</span>
0886                 figure(fh)
0887                 <span class="keyword">if</span> nargin&lt;4
0888                     ph=gca;
0889                 <span class="keyword">else</span>
0890                     axes(ph)
0891             <span class="keyword">end</span>
0892             <span class="keyword">end</span>
0893             
0894             <span class="keyword">if</span> nargin&lt;2
0895                 labels=this.labels;
0896             <span class="keyword">end</span>
0897             data=this.getDataAsVector(labels);
0898             missing=isnan(data);
0899             miss=missing(:,any(missing));
0900             
0901             <span class="keyword">if</span> ~noDisp
0902             pp=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(miss,<span class="string">'o'</span>);
0903             aux=labels(any(missing));
0904             <span class="keyword">for</span> i=1:length(pp)
0905                 set(pp(i),<span class="string">'DisplayName'</span>,[aux{i} <span class="string">' ('</span> num2str(sum(miss(:,i))) <span class="string">' frames)'</span>])
0906             <span class="keyword">end</span>
0907             legend(pp)
0908             title(<span class="string">'Missing markers'</span>)
0909             xlabel(<span class="string">'Time (frames)'</span>)
0910             set(gca,<span class="string">'YTick'</span>,[0 1],<span class="string">'YTickLabel'</span>,{<span class="string">'Present'</span>,<span class="string">'Missing'</span>})
0911             <span class="keyword">else</span>
0912                 fprintf([<span class="string">'Missing data in '</span> num2str(sum(any(missing,2))) <span class="string">'/'</span> num2str(size(missing,1)) <span class="string">' frames, avg. '</span> num2str(sum(missing(:))/sum(any(missing,2)),3) <span class="string">' per frame.\n'</span>]);
0913           <span class="keyword">end</span>
0914         <span class="keyword">end</span>
0915         
0916         <a name="_sub45" href="#_subfunctions" class="code">function [newThis,logL]=findOutliers(this,model,verbose)</a>
0917             <span class="comment">%Uses marker model data to assess outliers</span>
0918                 
0919                 d=this.getDataAsVector(model.markerLabels)';
0920                 l=this.labels;
0921                 [out,logL]=model.outlierDetect(d,-4);
0922                 [boolF,idx]=this.isaLabel(model.markerLabels);
0923                 aux(:,idx(boolF))=(out==1)';
0924                 this.Quality=aux;
0925             
0926             <span class="keyword">if</span> verbose
0927                 fprintf([<span class="string">'Outlier data in '</span> num2str(sum(any(out,1))) <span class="string">'/'</span> num2str(size(out,2)) <span class="string">' frames, avg. '</span> num2str(sum(out(:))/sum(any(out,1))) <span class="string">' per frame.\n'</span>]);
0928                 <span class="keyword">for</span> j=1:size(out,1)
0929                     <span class="keyword">if</span> sum(out(j,:)==1)&gt;0
0930                     disp([l{j} <span class="string">': '</span> num2str(sum(out(j,:)==1)) <span class="string">' frames'</span>])
0931                     <span class="keyword">end</span>
0932                 <span class="keyword">end</span>
0933             <span class="keyword">end</span>
0934 <span class="comment">%             s=naiveDistances.summaryStats(d);</span>
0935 <span class="comment">%             s=s(model.activeStats,:)';</span>
0936 <span class="comment">%             m=model.statMedian;</span>
0937 <span class="comment">%             m=m(model.activeStats);</span>
0938 <span class="comment">%             ss=model.getRobustStd(.94);</span>
0939 <span class="comment">%             ss=3*ss(model.activeStats); %3 standard devs</span>
0940 <span class="comment">%             aux=model.loglikelihood(d)&lt;-4^2/2;</span>
0941 <span class="comment">%             figure; pp=plot(s); axis tight; hold on;</span>
0942 <span class="comment">%             for j=1:size(s,2)</span>
0943 <span class="comment">%                 patch([1 size(s,1) size(s,1) 1],[m(j)-ss(j) m(j)-ss(j) m(j)+ss(j) m(j)+ss(j)],pp(j).Color,'FaceAlpha',.3,'EdgeColor','None')</span>
0944 <span class="comment">%                 plot(find(aux(j,:)),s(aux(j,:),j),'x','Color',pp(j).Color,'MarkerSize',4);</span>
0945 <span class="comment">%             end</span>
0946             newThis=this;
0947         <span class="keyword">end</span>
0948 
0949         <span class="comment">%Other</span>
0950         <a name="_sub46" href="#_subfunctions" class="code">function Fthis=fourierTransform(this,M) </a><span class="comment">%Changed on Apr 1st 2015, to return a timeseries. Now ignores second argument</span>
0951             <span class="keyword">if</span> nargin&gt;1
0952                 warning(<span class="string">'labTimeSeries:fourierTransform'</span>,<span class="string">'Ignoring second argument'</span>)
0953             <span class="keyword">end</span>
0954             [F,f] = DiscreteTimeFourierTransform(this.Data,this.sampFreq);
0955             Fthis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(F,f(1),f(2)-f(1),strcat(strcat(<span class="string">'F('</span>,this.labels),<span class="string">')'</span>));
0956             Fthis.TimeInfo.Units=<span class="string">'Hz'</span>;
0957         <span class="keyword">end</span>
0958 
0959         <a name="_sub47" href="#_subfunctions" class="code">function Sthis=spectrogram(this,labels,nFFT,tWin,tOverlap)</a>
0960             <span class="keyword">if</span> nargin&lt;2
0961                 labels=[];
0962             <span class="keyword">end</span>
0963             <span class="keyword">if</span> nargin&lt;3
0964                 nFFT=[];
0965             <span class="keyword">end</span>
0966             <span class="keyword">if</span> nargin&lt;4
0967                 tWin=[];
0968             <span class="keyword">end</span>
0969             <span class="keyword">if</span> nargin&lt;5
0970                 tOverlap=[];
0971             <span class="keyword">end</span>
0972             Sthis = spectroTimeSeries.getSTSfromTS(this,labels,nFFT,tWin,tOverlap);
0973         <span class="keyword">end</span>
0974 
0975         <a name="_sub48" href="#_subfunctions" class="code">function [ATS,bad]=align(this,eventTS,eventLabel,N,~)</a>
0976             <span class="keyword">if</span> nargin&lt;3 || isempty(eventLabel)
0977                 eventLabel=eventTS.labels(1);
0978             <span class="keyword">end</span>    
0979             <span class="keyword">if</span> nargin&lt;4 || isempty(N)
0980                 N=256*ones(size(eventLabel));
0981             <span class="keyword">end</span>
0982             [ATS,bad]=this.align_v2(eventTS.split(this.Time(1)-this.sampPeriod,this.Time(end)+this.sampPeriod),eventLabel,N);
0983         <span class="keyword">end</span>
0984         
0985         <a name="_sub49" href="#_subfunctions" class="code">function [DTS,bad]=discretize(this,eventTS,eventLabel,N,summaryFunction)</a>
0986             <span class="comment">%Discretizes a time-series by averaging data across different</span>
0987             <span class="comment">%phases of gait. The phases are defined by intervals between</span>
0988             <span class="comment">%given events, and in turn these can be divided into sub-phases</span>
0989             <span class="keyword">if</span> nargin&lt;3 || isempty(eventLabel)
0990                 eventLabel=eventTS.labels(1);
0991             <span class="keyword">end</span>
0992             <span class="comment">%NEw attempt, no alignment:</span>
0993             eventTimes=labTimeSeries.getArrayedEvents(eventTS,eventLabel);
0994             bad=any(isnan(eventTimes(1:end-1,:)),2);
0995             expEventTimes=alignedTimeSeries.expandEventTimes(eventTimes',N);
0996             ee=[expEventTimes(:); eventTimes(<span class="keyword">end</span>,1)];
0997             [slicedTS]=this.sliceTS(ee,0);
0998             <span class="keyword">if</span> nargin&lt;5 || isempty(summaryFunction)
0999                 summaryFunction=<span class="string">'nanmean'</span>;<span class="comment">%nanmean, only along the columns, so that if we have NAN data, and to account for the odd instance when we only have one row or data in our slicedTS</span>
1000             <span class="keyword">end</span>
1001             eval([<span class="string">'myfun=@(x) '</span> summaryFunction <span class="string">'(x,1);'</span>]);
1002             d=cell2mat(cellfun(@(x) myfun(x.Data),slicedTS,<span class="string">'UniformOutput'</span>,false)'); 
1003             [M,N1]=size(expEventTimes);        M2=size(d,2);
1004             d=permute(reshape(d,sum(N),N1,M2),[1,3,2]);
1005             DTS=alignedTimeSeries(0,1,d,this.labels,N,eventLabel,eventTimes');
1006         <span class="keyword">end</span>
1007 
1008         <a name="_sub50" href="#_subfunctions" class="code">function newThis=lowPassFilter(this,fcut)</a>
1009                 Wn=fcut*2/this.sampFreq;
1010                 Wst=min([2*Wn,Wn+.2*(1-Wn)]);
1011                filterList{1}=fdesign.lowpass(<span class="string">'Fp,Fst,Ap,Ast'</span>,Wn,Wst,3,10); <span class="comment">%</span>
1012                 <a href="#_sub51" class="code" title="subfunction newThis=lowPassFilter(this,fcut)">lowPassFilter</a>=design(filterList{1},<span class="string">'butter'</span>);
1013                 newData=filtfilthd_short(<a href="#_sub51" class="code" title="subfunction newThis=lowPassFilter(this,fcut)">lowPassFilter</a>,this.Data,<span class="string">'reflect'</span>,this.sampFreq);  <span class="comment">%Ext function</span>
1014                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,this.Time(1),this.sampPeriod,this.labels);
1015                 <span class="keyword">if</span> ~isfield(this.UserData,<span class="string">'processingInfo'</span>)
1016                     this.UserData.processingInfo={};
1017                 <span class="keyword">end</span>
1018                 newThis.UserData=this.UserData;
1019                 newThis.UserData.processingInfo{end+1}=filterList{1};
1020         <span class="keyword">end</span>
1021         
1022         <a name="_sub51" href="#_subfunctions" class="code">function newThis=highPassFilter(this,fcut)</a>
1023                 Wn=fcut*2/this.sampFreq;
1024                 filterList{1}=fdesign.highpass(<span class="string">'Fst,Fp,Ast,Ap'</span>,Wn/2,Wn,10,3);
1025                 <a href="#_sub52" class="code" title="subfunction newThis=highPassFilter(this,fcut)">highPassFilter</a>=design(filterList{1},<span class="string">'butter'</span>);
1026                 newData=filtfilthd_short(<a href="#_sub52" class="code" title="subfunction newThis=highPassFilter(this,fcut)">highPassFilter</a>,this.Data,<span class="string">'reflect'</span>,this.sampFreq);
1027                 newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,this.Time(1),this.sampPeriod,this.labels);
1028                 <span class="keyword">if</span> ~isfield(this.UserData,<span class="string">'processingInfo'</span>)
1029                     this.UserData.processingInfo={};
1030                 <span class="keyword">end</span>
1031                 newThis.UserData=this.UserData;
1032                 newThis.UserData.processingInfo{end+1}=filterList{1};
1033         <span class="keyword">end</span>
1034 
1035         <a name="_sub52" href="#_subfunctions" class="code">function newThis=monotonicFilter(this,Nderiv,Nreg)</a>
1036             <span class="keyword">if</span> nargin&lt;2 || isempty(Nderiv)
1037                 Nderiv=2;
1038             <span class="keyword">end</span>
1039             <span class="keyword">if</span> nargin&lt;3 || isempty(Nreg)
1040                Nreg=2;
1041             <span class="keyword">end</span>
1042             <span class="keyword">for</span> i=1:size(this.Data,2)
1043                this.Data(:,i)=monoLS(this.Data(:,i),[],Nderiv,Nreg);
1044             <span class="keyword">end</span>
1045             newThis=this;
1046         <span class="keyword">end</span>
1047 
1048         <a name="_sub53" href="#_subfunctions" class="code">function this=medianFilter(this,N)</a>
1049             <span class="keyword">if</span> mod(N,2)==0
1050                 error(<span class="string">'Only odd filter orders are allowed'</span>)
1051                 <span class="comment">%This actually works with even orders, but then the data</span>
1052                 <span class="comment">%gets shifted by half a sample, which is undesirable.</span>
1053             <span class="keyword">end</span>
1054 
1055             <span class="comment">%this.Data=medfilt1(this.Data,N,1,'omitnan'); %altered 12/4/2015 &quot;omitnan&quot; is not a valid input to medfilt1 in 2015a, 'omitnan' allowed for the median to be taken among the non-NaN elemets</span>
1056             this.Data=medfilt1(double(this.Data),double(N),double(1)); <span class="comment">%This back-compatible alternative works as if the last argument were 'includenan' (i.e. whenever there is a NaN in the window, the result is NaN)</span>
1057             <span class="comment">%Setting the samples outside the filter to NaN:</span>
1058             this.Data(1:floor(N/2),:)=NaN;
1059             this.Data(end-floor(N/2)+1:<span class="keyword">end</span>,:)=NaN;
1060         <span class="keyword">end</span>
1061 
1062     <span class="keyword">end</span>
1063 
1064     methods(Hidden)
1065         <a name="_sub54" href="#_subfunctions" class="code">function newThis=resampleLogical(this,newTs, newT0,newN)</a>
1066             <span class="comment">%newN=floor((this.Time(end)-newT0)/newTs +1);</span>
1067             <span class="comment">%Can this be deprecated in favor of resample with 'logical'</span>
1068             <span class="comment">%method?</span>
1069             newTime=[0:newN-1]*newTs+newT0;
1070             newN=length(newTime);
1071             newData=sparse([],[],false,newN,size(this.Data,2),newN);<span class="comment">% Sparse logical array of size newN x size(this.Data,2) and room for up to size(this.Data,2) true elements.</span>
1072            <span class="keyword">for</span> i=1:size(this.Data,2) <span class="comment">%Go over event labels</span>
1073                oldEventTimes=this.Time(this.Data(:,i)); <span class="comment">%Find time of old events</span>
1074                closestNewEventIndexes=round((oldEventTimes-newT0)/newTs) + 1; <span class="comment">%Find closest index in new event</span>
1075                <span class="keyword">if</span> any(closestNewEventIndexes&gt;newN) <span class="comment">%It could happen in case of down-sampling that the closest new index falls outside the range</span>
1076                    <span class="comment">%Option 1: set it to the last available sample (this</span>
1077                    <span class="comment">%would no longer be 'rounding')</span>
1078                    closestNewEventIndexes(closestNewEventIndexes&gt;newN)=newN;
1079                    <span class="comment">%Option 2: eliminate event, as it falls outside range.</span>
1080                    <span class="comment">%This may cause failure of other functions that rely on</span>
1081                    <span class="comment">%down-sampling of events not changing the number of</span>
1082                    <span class="comment">%events</span>
1083                    closestNewEventIndexes(closestNewEventIndexes&gt;newN)=[];
1084                <span class="keyword">end</span>
1085 
1086                newData(closestNewEventIndexes,i)=true;
1087            <span class="keyword">end</span>
1088            newThis=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,newT0,newTs,this.labels);
1089         <span class="keyword">end</span>
1090         
1091         <a name="_sub55" href="#_subfunctions" class="code">function [ATS,bad,Data]=align_v2(this,eventTS,eventLabel,N)</a>
1092             <span class="comment">%Efficient &amp; robust substitute for legacy align()</span>
1093             eventTimes=labTimeSeries.getArrayedEvents(eventTS,eventLabel);
1094             expEventTimes=alignedTimeSeries.expandEventTimes(eventTimes',N);
1095             Data=permute(this.getSample(expEventTimes),[1,3,2]);
1096             bad=any(isnan(eventTimes(1:end-1,:)),2);
1097             ATS=alignedTimeSeries(0,1,Data,this.labels,N,eventLabel,eventTimes');
1098         <span class="keyword">end</span>
1099     <span class="keyword">end</span>
1100 
1101     methods(Static)
1102         this=createLabTSFromTimeVector(data,time,labels); <span class="comment">%Need to compute appropriate t0 and Ts constants and call the constructor. Tricky if time is not uniformly sampled.</span>
1103         
1104         <a name="_sub56" href="#_subfunctions" class="code">function eventTimes=getArrayedEvents(eventTS,eventLabel)</a>
1105            <span class="keyword">if</span> nargin&gt;1
1106                 eventList=eventTS.getDataAsVector(eventLabel);
1107            <span class="keyword">else</span>
1108                eventList=eventTS.Data(:,1);
1109            <span class="keyword">end</span>
1110            <span class="comment">%Check needed: is eventList binary?</span>
1111            N=size(eventList,2); <span class="comment">%Number of events &amp; intervals to be found</span>
1112            <span class="comment">%auxList=double(eventList)*2.^[0:N-1]'; %List all events in a single vector, by numbering them differently.</span>
1113 
1114             <span class="comment">%refIdxLst=find(auxList==1);</span>
1115             refIdxLst=find(eventList(:,1)); <span class="comment">%Alt definition, to match what is returned if a single event was provided</span>
1116             M=length(refIdxLst)-1;
1117             auxTime=eventTS.Time;
1118             initTime=auxTime(refIdxLst); <span class="comment">%Initial time of each interval identified</span>
1119             eventTimes=nan(M+1,N); <span class="comment">%Duration of each interval</span>
1120             eventTimes(:,1)=initTime;
1121             <span class="keyword">for</span> i=1:M <span class="comment">%Going over strides</span>
1122                 t0=auxTime(refIdxLst(i));
1123                 lastEventIdx=refIdxLst(i);
1124                 <span class="keyword">for</span> j=1:N-1 <span class="comment">%Going over events</span>
1125                    <span class="comment">%nextEventIdx=lastEventIdx+find(auxList(lastEventIdx+1:refIdxLst(i+1)-1)==2^mod(j,N),1,'first');</span>
1126                    nextEventIdx=lastEventIdx+find(eventList(lastEventIdx+1:refIdxLst(i+1)-1,j+1),1,<span class="string">'first'</span>);
1127                    t1= auxTime(nextEventIdx); <span class="comment">%Look for next event</span>
1128                    <span class="keyword">if</span> ~isempty(t1) &amp;&amp; ~isempty(t0)
1129                        eventTimes(i,j+1)=t1;
1130                         lastEventIdx=nextEventIdx;
1131                    <span class="keyword">end</span>
1132 
1133                 <span class="keyword">end</span>
1134             <span class="keyword">end</span>
1135         <span class="keyword">end</span>
1136 
1137         <a name="_sub57" href="#_subfunctions" class="code">function [alignedTS,originalDurations]=stridedTSToAlignedTS(stridedTS,N) </a>
1138             error(<span class="string">'Deprecated. Use labTS.align()'</span>)
1139             <span class="comment">%To be used after splitByEvents</span>
1140             <span class="keyword">if</span> numel(stridedTS)~=0
1141                 <span class="keyword">if</span> ~islogical(stridedTS{1}.Data)
1142                     aux=zeros(sum(N),size(stridedTS{1}.Data,2),size(stridedTS,1));
1143                 <span class="keyword">else</span>
1144                     aux=false(sum(N),size(stridedTS{1}.Data,2),size(stridedTS,1));
1145                 <span class="keyword">end</span>
1146                 Nstrides=size(stridedTS,1);
1147                 Nphases=size(stridedTS,2);
1148                 originalDurations=nan(Nstrides,Nphases);
1149                 <span class="keyword">for</span> i=1:Nstrides <span class="comment">%Going over strides</span>
1150                     M=[0,cumsum(N)];
1151                     <span class="keyword">for</span> j=1:Nphases <span class="comment">%Going over aligned phases</span>
1152                         <span class="keyword">if</span> isa(stridedTS{i,j},<span class="string">'labTimeSeries'</span>)
1153                             originalDurations(i,j)=stridedTS{i,j}.timeRange;
1154                             <span class="keyword">if</span> ~isempty(stridedTS{i,j}.Data) &amp;&amp; sum(~isnan(stridedTS{i,j}.Data(:,1)))&gt;1
1155                                 aa=<a href="#_sub12" class="code" title="subfunction newThis=resampleN(this,newN,method)">resampleN</a>(stridedTS{i,j},N(j));
1156                                 aux(M(j)+1:M(j+1),:,i)=aa.Data;
1157                             <span class="keyword">else</span> <span class="comment">%Separating by strides returned empty labTimeSeries, possibly because of events in disorder</span>
1158                                 <span class="keyword">if</span> islogical(stridedTS{i,j}.Data)
1159                                     aux(M(j)+1:M(j+1),:,i)=false;
1160                                 <span class="keyword">else</span>
1161                                     aux(M(j)+1:M(j+1),:,i)=NaN;
1162                                 <span class="keyword">end</span>
1163                             <span class="keyword">end</span>
1164                         <span class="keyword">else</span>
1165                             error(<span class="string">'labTimeSeries:stridedTSToAlignedTS'</span>,[<span class="string">'First argument is not a cell array of labTimeSeries. Element i='</span> num2str(i) <span class="string">', j='</span> num2str(j)])
1166                         <span class="keyword">end</span>
1167                     <span class="keyword">end</span>
1168                 <span class="keyword">end</span>
1169                 alignmentLabels=cell(size(N)); <span class="comment">%Need to populate this field properly</span>
1170                 alignedTS=alignedTimeSeries(0,1,aux,stridedTS{1}.labels,N,alignmentLabels); <span class="comment">%On May 2nd 2017, Pablo changed to have sampling time =1 [time vector now counts samples]</span>
1171             <span class="keyword">else</span>
1172                 alignmentLabels=cell(size(N));
1173                 alignedTS=alignedTimeSeries(0,1,zeros(0,0),[],N,alignmentLabels);
1174                 originalDurations=[];
1175             <span class="keyword">end</span>
1176         <span class="keyword">end</span>
1177 
1178         <a name="_sub58" href="#_subfunctions" class="code">function [figHandle,plotHandles]=plotStridedTimeSeries(stridedTS,figHandle,plotHandles)</a>
1179                 <span class="keyword">if</span> nargin&lt;2
1180                     figHandle=[];
1181                 <span class="keyword">end</span>
1182                 <span class="keyword">if</span> nargin&lt;3
1183                     plotHandles=[];
1184                 <span class="keyword">end</span>
1185                N=2^ceil(log2(1.5/stridedTS{1}.sampPeriod));
1186                structure=labTimeSeries.stridedTSToAlignedTS(stridedTS,N);
1187                [figHandle,plotHandles]=<a href="#_sub41" class="code" title="subfunction [h,plotHandles]=plot(this,h,labels,plotHandles,events,color,lineWidth) ">plot</a>(structure,figHandle,plotHandles); <span class="comment">%Using the alignedTimeSeries plot function</span>
1188         <span class="keyword">end</span>
1189 
1190         <a name="_sub59" href="#_subfunctions" class="code">function this=join(labTSCellArray)</a>
1191             masterSampPeriod=labTSCellArray{1}.sampPeriod;
1192             masterLabels=labTSCellArray{1}.labels;
1193             newData=labTSCellArray{1}.Data;
1194            <span class="keyword">for</span> i=2:length(labTSCellArray(:))
1195                <span class="comment">%Check sampling rate &amp; dimensions are consistent, and append</span>
1196                <span class="comment">%at end of data</span>
1197                <span class="keyword">if</span> all(cellfun(@strcmp,masterLabels,labTSCellArray{i}.labels)) &amp;&amp; masterSampPeriod==labTSCellArray{i}.sampPeriod
1198                    newData=[newData;labTSCellArray{i}.Data];
1199                <span class="keyword">else</span>
1200                   warning([num2str(i) <span class="string">'-th element of input cell array does not have labels or sampling period consistent with other elements.'</span>]);
1201                <span class="keyword">end</span>
1202                this=<a href="labTimeSeries.html" class="code" title="">labTimeSeries</a>(newData,labTSCellArray{1}.Time(1),masterSampPeriod,masterLabels);
1203            <span class="keyword">end</span>
1204         <span class="keyword">end</span>
1205     <span class="keyword">end</span>
1206 
1207 
1208 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Tue 16-Apr-2024 13:38:13 by <strong><a href="https://github.com/gllmflndn/m2html">m2html</a></strong> &copy; 2003-2022</address>
</body>
</html>